<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6R IK Newton VJ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 11px;}
        canvas { display: block; width: 100vw; height: 100vh; }
        
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #00d2ff; }

        #ui-container {
            position: absolute; top: 10px; left: 10px;
            width: 300px;
            max-height: 95vh;
            overflow-y: auto;
            background: rgba(8, 8, 10, 0.92);
            backdrop-filter: blur(16px);
            padding: 0;
            border-radius: 8px;
            border: 1px solid #333;
            color: #eee;
            user-select: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8);
            transition: opacity 0.3s;
        }
        
        .header {
            padding: 10px;
            background: linear-gradient(90deg, #111, #000);
            border-bottom: 1px solid #00d2ff;
            display: flex; justify-content: space-between; align-items: center;
            position: sticky; top: 0; z-index: 10;
        }
        h1 { margin: 0; font-size: 14px; color: #fff; letter-spacing: 1px; font-weight: 700; }
        h1 span { color: #00d2ff; }
        
        #audio-vis { width: 100%; height: 40px; background: #000; display: block; border-bottom: 1px solid #222; }
        .audio-controls { padding: 10px; display: flex; gap: 5px; background: #111; border-bottom: 1px solid #222; }
        button {
            flex: 1; padding: 6px; border: 1px solid #444; background: #222; color: #ccc;
            cursor: pointer; border-radius: 3px; font-size: 10px; text-transform: uppercase; font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { background: #333; color: #fff; border-color: #666; }
        button.active { background: #00d2ff; color: #000; border-color: #00d2ff; }
        input[type="file"] { display: none; }

        .section { border-bottom: 1px solid #222; }
        .section-header {
            padding: 8px 10px; cursor: pointer; font-weight: bold; color: #888;
            text-transform: uppercase; display: flex; justify-content: space-between;
            background: #0f0f0f; transition: color 0.2s;
        }
        .section-header:hover { color: #fff; background: #1a1a1a; }
        .section-content { padding: 10px; display: none; }
        .section.open .section-content { display: block; }
        .section.open .section-header { color: #00d2ff; border-bottom: 1px solid #222; }
        .arrow { transition: transform 0.2s; }
        .section.open .arrow { transform: rotate(90deg); }

        .control-group { margin-bottom: 8px; }
        .label-row { display: flex; justify-content: space-between; margin-bottom: 4px; color: #aaa; }
        
        /* Disabled state styling */
        .control-group.disabled { opacity: 0.4; pointer-events: none; filter: grayscale(100%); }
        .control-group.disabled .label-row span:last-child { color: #00d2ff; } /* Highlight value */

        input[type="range"] {
            width: 100%; cursor: pointer; accent-color: #00d2ff; height: 4px;
            background: #333; border-radius: 2px; appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 10px; width: 10px;
            background: #eee; border-radius: 50%; margin-top: -3px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type="color"] {
            width: 100%; height: 20px; border: none; background: none; cursor: pointer;
        }
        input[type="checkbox"] { accent-color: #00d2ff; }
        select { width: 100%; background: #222; color: #fff; border: 1px solid #444; padding: 4px; border-radius: 3px; }

        #mod-list { display: flex; flex-direction: column; gap: 6px; margin-top: 8px; }
        .mod-item {
            background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 6px;
            display: flex; flex-direction: column; gap: 4px; position: relative;
        }
        .mod-item-header { display: flex; justify-content: space-between; align-items: center; }
        .mod-remove { color: #ff4444; cursor: pointer; font-weight: bold; font-size: 14px; padding: 0 4px;}
        .mod-row { display: flex; gap: 4px; align-items: center; }
        .mod-input { flex: 1; background: #000; border: 1px solid #444; color: #00d2ff; padding: 2px 4px; border-radius: 2px; width: 0; font-family: monospace;}
        .mod-label { font-size: 9px; color: #666; text-transform: uppercase; }

        .fps { position: absolute; top: 10px; right: 10px; color: #00d2ff; font-family: monospace; font-weight: bold; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; pointer-events: none;}
    </style>
</head>
<body>

<div class="fps"><span id="fps-counter">60</span> FPS</div>

<div id="ui-container">
    <div class="header">
        <h1>6R ROBOT <span>IK SOLVER</span></h1>
    </div>

    <!-- AUDIO VISUALIZER -->
    <canvas id="audio-vis" width="320" height="40"></canvas>
    <div class="audio-controls">
        <button id="btn-file">Open File</button>
        <button id="btn-mic">Use Mic</button>
        <input type="file" id="inp-file" accept="audio/*">
    </div>

    <!-- MODULATION MATRIX -->
    <div class="section open">
        <div class="section-header" onclick="toggleSection(this)">
            Modulation Matrix <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <button id="btn-add-mod" style="width:100%; margin-bottom:5px;">+ Add Modulation Link</button>
            <div id="mod-list"></div>
        </div>
    </div>

    <!-- ROBOT LINK PARAMETERS -->
    <div class="section open">
        <div class="section-header" onclick="toggleSection(this)">
            Robot Link Params <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <div class="label-row" style="color:#00d2ff; font-weight:bold;"><span>Spatial Axis Maps To:</span></div>
                <select id="spatialParam">
                    <option value="-1">None (Standard Depth)</option>
                    <option value="0">Link Length (a)</option>
                    <option value="1">Link Offset (d)</option>
                    <option value="2">Twist (α)</option>
                    <option value="3">Joint Angle (θ)</option>
                    <option value="4">Poly Complexity</option>
                    <option value="5">Symmetry</option>
                </select>
            </div>
            <div class="control-group" id="group-paramLinkA">
                <div class="label-row"><span>Link Length (a)</span><span id="val-linkA">1.00</span></div>
                <input type="range" id="paramLinkA" min="0.0" max="2.0" step="0.01" value="1.0">
            </div>
            <div class="control-group" id="group-paramLinkD">
                <div class="label-row"><span>Link Offset (d)</span><span id="val-linkD">0.50</span></div>
                <input type="range" id="paramLinkD" min="0.0" max="2.0" step="0.01" value="0.5">
            </div>
            <div class="control-group" id="group-paramTwist">
                <div class="label-row"><span>Twist (α)</span><span id="val-twist">0.50</span></div>
                <input type="range" id="paramTwist" min="0.0" max="6.28" step="0.01" value="0.5">
            </div>
            <div class="control-group" id="group-paramTheta">
                <div class="label-row"><span>Joint Angle (θ)</span><span id="val-theta">0.00</span></div>
                <input type="range" id="paramTheta" min="0.0" max="6.28" step="0.01" value="0.0">
            </div>
            <div class="control-group" id="group-paramComplexity">
                <div class="label-row"><span style="color:#88ff88">Poly Complexity</span><span id="val-complexity">1.00</span></div>
                <input type="range" id="paramComplexity" min="0.0" max="2.0" step="0.01" value="1.0">
            </div>
            <div class="control-group" id="group-paramSymmetry">
                <div class="label-row"><span>Symmetry (Cyclic)</span><span id="val-symmetry">0.00</span></div>
                <input type="range" id="paramSymmetry" min="0.0" max="1.0" step="0.01" value="0.0">
            </div>
        </div>
    </div>

    <!-- CAMERA TRANSFORM -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            Camera <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <div class="label-row"><span>Roll (Z-Axis)</span><span id="val-rotz">0.00</span></div>
                <input type="range" id="paramRotZ" min="-3.14" max="3.14" step="0.01" value="0.0">
            </div>
            <input type="hidden" id="paramRotX" value="-0.1">
            <input type="hidden" id="paramRotY" value="3.14">
        </div>
    </div>

    <!-- COLOR PALETTE -->
    <div class="section open">
        <div class="section-header" onclick="toggleSection(this)">
            Color & Grade <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <div class="label-row"><span>Mode</span></div>
                <select id="colorMode">
                    <option value="0">Basins (Roots)</option>
                    <option value="3">Deep Gradient (Custom)</option>
                    <option value="4">Lyapunov (Chaos)</option>
                    <option value="1">Electric (Speed)</option>
                    <option value="2">Traps (Geometric)</option>
                    <option value="6">Normal (Surface)</option>
                    <option value="8">Wave Grid</option>
                    <option value="12">Gold (Metallic)</option>
                    <option value="13">Silver (Metallic)</option>
                    <option value="11">Neon Dark</option>
                </select>
            </div>
            <div class="control-group">
                <div class="label-row"><span>Color A (Shadows)</span></div>
                <input type="color" id="col-a" value="#000000">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Color B (Mids)</span></div>
                <input type="color" id="col-b" value="#005588">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Color C (Highlights)</span></div>
                <input type="color" id="col-c" value="#ffffff">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Phase Shift</span><span id="val-phase">0.0</span></div>
                <input type="range" id="paramPhase" min="0" max="6.28" step="0.01" value="0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Exposure</span><span id="val-exp">1.00</span></div>
                <input type="range" id="paramExposure" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Contrast</span><span id="val-contrast">1.10</span></div>
                <input type="range" id="paramContrast" min="0.5" max="2.0" step="0.05" value="1.1">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Saturation</span><span id="val-sat">1.20</span></div>
                <input type="range" id="paramSat" min="0.0" max="2.0" step="0.05" value="1.2">
            </div>
        </div>
    </div>

    <!-- FRACTAL PARAMS -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            Solver Params <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <div class="label-row"><span>Newton Steps</span><span id="val-steps">5</span></div>
                <input type="range" id="paramSteps" min="1" max="15" step="1" value="5">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Gradient Fix</span><span id="val-correct">1.00</span></div>
                <input type="range" id="paramCorrect" min="0.0" max="1.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Z-Stretch (Time)</span><span id="val-stretch">1.00</span></div>
                <input type="range" id="paramStretch" min="0.1" max="3.0" step="0.01" value="1.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Parameter Shift</span><span id="val-shift">0.00</span></div>
                <input type="range" id="paramShift" min="-5.0" max="5.0" step="0.01" value="0.0">
            </div>
        </div>
    </div>

    <!-- RETRO FX -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            Retro FX (Masking) <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <div class="label-row"><span>Resolution Scale</span><span id="val-res">0.50</span></div>
                <input type="range" id="paramRes" min="0.1" max="1.5" step="0.05" value="0.50">
            </div>
            <div class="control-group">
                <div class="label-row"><span>CRT Lines</span><span id="val-scan">0.50</span></div>
                <input type="range" id="paramScan" min="0.0" max="1.0" step="0.05" value="0.5">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Aberration</span><span id="val-abb">2.00</span></div>
                <input type="range" id="paramAbb" min="0.0" max="5.0" step="0.1" value="2.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Noise</span><span id="val-noise">0.10</span></div>
                <input type="range" id="paramNoise" min="0.0" max="0.5" step="0.01" value="0.1">
            </div>
        </div>
    </div>

    <!-- QUALITY -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            Quality / Perf <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <label class="label-row" style="align-items:center; cursor:pointer;">
                    <span style="color:#ff4444;">Low Spec Mode</span>
                    <input type="checkbox" id="paramLowSpec">
                </label>
            </div>
            <div class="control-group">
                <div class="label-row"><span>Max Ray Steps</span><span id="val-raysteps">80</span></div>
                <input type="range" id="paramRaySteps" min="20" max="200" step="10" value="80">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Density</span><span id="val-density">1.50</span></div>
                <input type="range" id="paramDensity" min="0.1" max="5.0" step="0.1" value="1.5">
            </div>
        </div>
    </div>
    
    <!-- FLUID VOXELS -->
    <div class="section">
        <div class="section-header" onclick="toggleSection(this)">
            Fluid Voxels <span class="arrow">▶</span>
        </div>
        <div class="section-content">
            <div class="control-group">
                <label class="label-row" style="align-items:center; cursor:pointer;">
                    <span style="color:#00d2ff;">Enable Fluid</span>
                    <input type="checkbox" id="paramFluid">
                </label>
            </div>
            <div class="control-group">
                <div class="label-row"><span>Anti-Flicker</span><span id="val-despeckle">1.00</span></div>
                <input type="range" id="paramDespeckle" min="0.0" max="1.0" step="0.05" value="1.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Grid Size</span><span id="val-grid">60</span></div>
                <input type="range" id="paramGrid" min="10" max="200" step="5" value="60">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Flow Speed</span><span id="val-flow">1.00</span></div>
                <input type="range" id="paramFlow" min="0.0" max="5.0" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <div class="label-row"><span>Perturb</span><span id="val-perturb">0.20</span></div>
                <input type="range" id="paramPerturb" min="0.0" max="2.0" step="0.05" value="0.2">
            </div>
        </div>
    </div>
</div>

<canvas id="glcanvas"></canvas>

<!-- SHADERS -->
<script id="vs" type="x-shader/x-vertex">#version 300 es
in vec4 position;
out vec2 uv;
void main() { uv = position.xy * 0.5 + 0.5; gl_Position = position; }
</script>

<script id="fs-fractal" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 fragColor;
in vec2 uv;
uniform vec2 uRes;
uniform vec3 uCamPos, uCamFwd, uCamRight, uCamUp;
uniform int uColorMode, uSteps, uRayStepsMax;
uniform float uStretch, uShift, uDensity, uCorrectStr, uTime, uPhase;
uniform vec3 uColA, uColB, uColC;
uniform float uExp, uCon, uSat;

// NEW: Parameters passed raw to shader
// 0:LinkA, 1:LinkD, 2:Twist, 3:Theta, 4:Complexity, 5:Symmetry
uniform float uParams[6];
uniform int uSpatialIdx; // Which param maps to spatial depth (-1 = none)

vec2 cmul(vec2 a, vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }
vec2 cdiv(vec2 a, vec2 b) { float d = dot(b,b); return vec2(dot(a,b), a.y*b.x - a.x*b.y) / (d + 1e-9); }

// Generate coeffs and evaluate P/P' on the fly
// This replaces the pre-calculated uCoeffs array
void evalPolyDynamic(vec2 z, float p[6], out vec2 pVal, out vec2 dpVal) {
    // Unpack params
    float linkA = abs(p[0]); // Ensure positive for pow
    float linkD = p[1];
    float twist = p[2];
    float theta = p[3];
    float complexity = p[4];
    float symmetry = p[5];

    pVal = vec2(1.0, 0.0); // Coeff 16 (Leading term 1.0)
    dpVal = vec2(0.0);
    
    // Horner's Method integrated with Coefficient Generation
    // High order to low order
    
    for(int k=15; k>=0; k--) {
        // --- Coefficient Gen Logic ---
        float isSym = (k % 4 == 0) ? 1.0 : (1.0 - symmetry);
        
        float phase = twist * float(k) + theta;
        float mag = pow(linkA, float(16-k)*0.2) * isSym;
        float noise = sin(linkD * float(k) + theta * 2.0) * complexity;
        
        float re = cos(phase) * mag + noise * 0.2;
        float im = sin(phase) * mag + noise * 0.2;
        
        float damp = 1.0 / (abs(float(16-k)) + 1.0);
        vec2 c = vec2(re, im) * damp;
        
        // --- Horner Step ---
        
        // P(z) = P(z)*z + c
        pVal = cmul(pVal, z) + c;
        
        // P'(z) logic requires knowing the power, which is tricky in a single pass 
        // without stored coeffs unless we do a separate accumulation.
        // Actually, separate accumulation is safer for correctness here.
        // But to keep it fast, we can approximate or use a 2-pass approach?
        // Let's do a 2-pass approach inside the loop? No, that's O(N^2).
        
        // Alternative: P'(z) = sum( i * c_i * z^(i-1) )
        // We can build P' using Horner too.
        // P'(z)_new = P'(z)_old * z + P(z)_old_before_add
        // Wait, standard derivative rule for Horner:
        // if P(z) = (...((a_n z + a_{n-1})z + ... ) + a_0
        // val = val * z + c
        // der = der * z + val_prev
        // Note: val_prev is the value of the polynomial created by higher terms BEFORE multiplying by z.
    }
    
    // Re-run for derivative? Or use the math property.
    // The standard property: if P(z) = b_0, P'(z) = d_0
    // b_k = a_k + z * b_{k+1}
    // d_k = b_{k+1} + z * d_{k+1}
    // We are iterating downwards (k=15..0). 
    // This is forward Horner. 
    // Actually, let's just do the explicit separate loop to be 100% sure of the math 
    // even if it costs a bit more. Correctness > Micro-opt for now.
    
    // We need to regenerate coeffs. This is the cost of "Holotopy".
    // Optimization: We can generate them into a temporary array? 
    // GLSL Arrays can't be too big, but 17 is fine.
    vec2 c[17];
    c[16] = vec2(1.0, 0.0);
    
    for(int k=15; k>=0; k--) {
        float isSym = (k % 4 == 0) ? 1.0 : (1.0 - symmetry);
        float phase = twist * float(k) + theta;
        float mag = pow(linkA, float(16-k)*0.2) * isSym;
        float noise = sin(linkD * float(k) + theta * 2.0) * complexity;
        float damp = 1.0 / (abs(float(16-k)) + 1.0);
        c[k] = vec2(cos(phase)*mag + noise*0.2, sin(phase)*mag + noise*0.2) * damp;
    }
    
    // Evaluate P
    pVal = c[16];
    for(int i=15; i>=0; i--) {
        pVal = cmul(pVal, z) + c[i];
    }
    
    // Evaluate P'
    dpVal = 16.0 * c[16];
    for(int i=15; i>=1; i--) {
        dpVal = cmul(dpVal, z) + (float(i) * c[i]);
    }
}

// Distance estimator for Newton Fractal
void map(vec3 p, out float phi, out vec4 trap) {
    vec2 z = p.xy;
    
    // Spatial Z drives the holotopy parameter
    float spatialVal = p.z * uStretch + uShift;
    
    // Construct local parameters
    float pLocal[6];
    pLocal[0] = uParams[0]; pLocal[1] = uParams[1]; pLocal[2] = uParams[2];
    pLocal[3] = uParams[3]; pLocal[4] = uParams[4]; pLocal[5] = uParams[5];
    
    // Override if spatial index is selected
    if(uSpatialIdx >= 0 && uSpatialIdx < 6) {
        // Scale spatialVal to reasonable ranges based on param type?
        // Or just raw. Let's use raw but maybe mod 2PI for angles?
        // For visualizer consistency, raw linear is best for continuity.
        pLocal[uSpatialIdx] += spatialVal; 
    }

    float minStep = 1e5;
    
    // Newton Iteration
    for(int i=0; i<uSteps; i++) {
        vec2 val, der;
        evalPolyDynamic(z, pLocal, val, der);
        
        if(dot(der,der) < 1e-6) der = vec2(1e-3, 0.0);
        vec2 step = cdiv(val, der);
        z -= step;
        
        float sl = length(step);
        if(sl < minStep) minStep = sl;
        if(sl < 0.001) break;
    }
    
    phi = -log(minStep + 1e-9) * 0.15;
    trap = vec4(atan(z.y,z.x), 0., 0., length(z));
}

vec3 getNormal(vec3 p) {
    float e=0.005; float d; vec4 t; map(p,d,t);
    float x; map(p+vec3(e,0,0),x,t);
    float y; map(p+vec3(0,e,0),y,t);
    float z; map(p+vec3(0,0,e),z,t);
    return normalize(vec3(x-d, y-d, z-d));
}

vec3 palette(float t) {
    vec3 a = uColA; vec3 b = uColB; vec3 c = uColC;
    t = fract(t + uPhase);
    if(t < 0.33) return mix(a, b, t*3.0);
    if(t < 0.66) return mix(b, c, (t-0.33)*3.0);
    return mix(c, a, (t-0.66)*3.0);
}

vec3 paletteStd(float t) {
    return vec3(0.5) + vec3(0.5)*cos(6.28318*(vec3(1.0)*t + vec3(0.0, 0.33, 0.67) + uPhase));
}

void main() {
    vec2 scr = (gl_FragCoord.xy - 0.5*uRes)/uRes.y;
    vec3 ro = uCamPos;
    vec3 rd = normalize(uCamFwd + scr.x*uCamRight + scr.y*uCamUp);

    float noise = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233)))*43758.5453);
    float t = 0.1;
    vec3 accCol = vec3(0.);
    float accAlpha = 0.;
    
    // Raymarch
    for(int i=0; i<200; i++) { 
        if(i>=uRayStepsMax) break;
        vec3 p = ro + rd*t;
        
        // Bounding box for optimization
        if(length(p.xy)>6.0) { t+=0.5; continue; }

        float phi; vec4 trap;
        map(p, phi, trap);

        if(isnan(phi) || isinf(phi)) phi = 10.0;

        float dist = phi - 0.5; // Surface thickness threshold
        
        // Soft gradient correction
        if(uCorrectStr > 0.01 && dist < 1.0) {
            dist /= (1.2); // Simplified Lipschitz bound
        }

        float thick = 0.05; // Thickness of the "fluid" strands
        if(dist < thick) {
            float inten = max(0., thick-dist);
            inten = pow(inten, 0.8) * uDensity * 12.0;
            
            vec3 col = vec3(0.);
            
            // COLOR MODES
            if(uColorMode==3) { float tval = trap.x * 0.1 + p.z * 0.03; col = palette(tval); } 
            else if (uColorMode == 0) col = paletteStd(trap.x*0.159); // Basins
            else if (uColorMode == 1) { // Electric
                float e=trap.w*0.5; // Length
                col = vec3(0.2,0.6,1.0)*e + vec3(1.0,0.8,0.2)*(0.1/(e+0.01)); 
            }
            else if (uColorMode == 4) { // Chaos
                float chaos = fract(trap.x * 3.0);
                col = mix(vec3(0.), vec3(1.,0.,0.2), chaos);
            }
            else if (uColorMode == 6) { if(inten>0.2) col = getNormal(p)*0.5+0.5; else col=vec3(0.5); }
            else if (uColorMode == 8) { // Grid
                vec3 q = fract(p*2.0)-0.5;
                float g = 1.0-smoothstep(0.02,0.05, min(min(abs(q.x),abs(q.y)), abs(q.z)));
                col = vec3(0.1,0.8,1.0) * g * 2.0;
            }
            else if (uColorMode == 12) { // Gold
                if(inten>0.2) {
                    vec3 n = getNormal(p);
                    vec3 ld = normalize(vec3(0.5,1.0,-0.5));
                    float spec = pow(max(dot(reflect(-ld,n), -rd), 0.0), 8.0);
                    col = vec3(1.0, 0.84, 0.0) * (0.2 + 0.8*max(dot(n,ld),0.0)) + vec3(spec);
                } else col = vec3(0.5);
            }
            else if (uColorMode == 13) { // Silver
                if(inten>0.2) {
                    vec3 n = getNormal(p);
                    vec3 ld = normalize(vec3(0.5,1.0,-0.5));
                    float spec = pow(max(dot(reflect(-ld,n), -rd), 0.0), 12.0);
                    col = vec3(0.95) * (0.3 + 0.7*max(dot(n,ld),0.0)) + vec3(spec);
                } else col = vec3(0.5);
            }
            else if (uColorMode == 11) { // Neon
                 col = paletteStd(trap.x + uTime*0.1);
                 if(fract(p.z*5.0) < 0.1) col *= 2.0;
            }
            else col = vec3(1.0);

            float a = clamp(inten*0.05, 0., 1.);
            accCol += col * a * (1.0 - accAlpha);
            accAlpha += a;
            if(accAlpha > 0.99) break;
        }

        float step = max(abs(dist)*0.4, 0.01);
        step *= 1.0 + (noise-0.5)*1.2;
        t += step;
        if(t > 25.0) break;
    }
    
    // Grading
    accCol *= uExp;
    accCol = (accCol-0.5)*uCon+0.5;
    float lum = dot(accCol, vec3(0.299,0.587,0.114));
    accCol = mix(vec3(lum), accCol, uSat);
    
    fragColor = vec4(accCol, accAlpha);
}
</script>

<script id="fs-post" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 fragColor;
in vec2 uv;
uniform sampler2D uTex;
uniform vec2 uRes;
uniform float uScan, uAbb, uNoise, uTime, uGridSize, uFlowSpd, uPerturb, uDespeckleStr;
uniform bool uFluid;

float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
float noise(vec2 p) {
    vec2 i = floor(p); vec2 f = fract(p);
    float a = hash(i); float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}
vec2 curlNoise(vec2 p, float t) {
    float eps = 0.1;
    float n1 = noise(p + vec2(eps, 0.0) + t);
    float n2 = noise(p - vec2(eps, 0.0) + t);
    float n3 = noise(p + vec2(0.0, eps) + t);
    float n4 = noise(p - vec2(0.0, eps) + t);
    return vec2(n3 - n4, n2 - n1);
}

void main() {
    vec2 sampleUV = uv;
    vec3 col = vec3(0.0);
    float gap = 1.0;

    if (uFluid) {
        float size = uGridSize; 
        vec2 gridUV = floor(uv * size) / size;
        vec2 center = gridUV + (0.5 / size);
        float t = uTime * uFlowSpd;
        vec2 flow = curlNoise(gridUV * 4.0, t) * 0.02 * (1.0 + uPerturb); 
        sampleUV = clamp(center + flow, 0.0, 1.0);
        vec2 local = fract(uv * size);
        float border = 0.05; 
        gap = step(border, local.x) * step(border, local.y) * step(local.x, 1.0-border) * step(local.y, 1.0-border);
    }

    vec2 dist = (uv - 0.5) * 2.0; 
    vec2 off = dist * 0.002 * uAbb; 
    
    float r = texture(uTex, sampleUV - off).r;
    float g = texture(uTex, sampleUV).g;
    float b = texture(uTex, sampleUV + off).b;
    col = vec3(r,g,b);

    if(uDespeckleStr > 0.01) {
        vec2 px = 1.0/uRes;
        vec3 c = col;
        vec3 n1 = texture(uTex, sampleUV + vec2(px.x, 0.0)).rgb;
        vec3 n2 = texture(uTex, sampleUV - vec2(px.x, 0.0)).rgb;
        vec3 n3 = texture(uTex, sampleUV + vec2(0.0, px.y)).rgb;
        vec3 n4 = texture(uTex, sampleUV - vec2(0.0, px.y)).rgb;
        vec3 minC = min(min(n1, n2), min(n3, n4));
        vec3 maxC = max(max(n1, n2), max(n3, n4));
        col = mix(c, clamp(c, minC, maxC), uDespeckleStr);
    }

    if (uFluid) col *= gap;

    if(uScan > 0.01) {
        float scan = sin(uv.y * uRes.y * 3.14159) * 0.5 + 0.5; 
        col *= mix(1.0, scan, uScan * 0.5); 
    }
    
    if(uNoise > 0.01) {
        float n = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
        col += (n - 0.5) * uNoise;
    }
    
    fragColor = vec4(col, 1.0);
}
</script>

<script>
(function() {
    // --- GLOBALS ---
    var ui = {
        audioVis: document.getElementById('audio-vis'),
        modList: document.getElementById('mod-list'),
        btnFile: document.getElementById('btn-file'),
        inpFile: document.getElementById('inp-file'),
        btnMic: document.getElementById('btn-mic'),
        btnAddMod: document.getElementById('btn-add-mod'),
        fps: document.getElementById('fps-counter'),
        spatialParam: document.getElementById('spatialParam'),
        params: {} 
    };
    
    var frameCount = 0;
    var currentAudio = null;
    var activeModTargets = new Set();
    
    // Map of spatial index to UI ID
    const SPATIAL_MAP = {
        '0': 'paramLinkA',
        '1': 'paramLinkD',
        '2': 'paramTwist',
        '3': 'paramTheta',
        '4': 'paramComplexity',
        '5': 'paramSymmetry'
    };

    document.querySelectorAll('input, select').forEach(el => {
        if(el.id) ui.params[el.id] = el;
        if(el.type === 'range' && el.id.startsWith('param')) {
            const label = document.getElementById('val-' + el.id.replace('param', '').toLowerCase());
            if(label) el.addEventListener('input', () => label.innerText = parseFloat(el.value).toFixed(2));
        }
    });

    var AudioCtx = window.AudioContext || window.webkitAudioContext;
    var actx, analyser, sourceNode, dataArray;
    var audioBands = { bass: 0, mid: 0, high: 0, vol: 0 };

    async function initAudio() {
        if(actx) return;
        actx = new AudioCtx();
        analyser = actx.createAnalyser();
        analyser.fftSize = 512;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
    }

    ui.btnFile.addEventListener('click', () => ui.inpFile.click());
    ui.inpFile.addEventListener('change', async (e) => {
        await initAudio();
        if(actx.state === 'suspended') await actx.resume();
        if(currentAudio) { currentAudio.pause(); currentAudio = null; }
        if(sourceNode) { try { sourceNode.disconnect(); } catch(e){} }

        const file = e.target.files[0];
        const url = URL.createObjectURL(file);
        const audio = new Audio(url);
        audio.loop = true;
        currentAudio = audio;
        audio.play().catch(e => console.warn("Audio fail", e));
        sourceNode = actx.createMediaElementSource(audio);
        sourceNode.connect(analyser);
        sourceNode.connect(actx.destination);
        ui.btnFile.classList.add('active'); ui.btnMic.classList.remove('active');
    });

    ui.btnMic.addEventListener('click', async () => {
        await initAudio();
        if(actx.state === 'suspended') await actx.resume();
        if(currentAudio) { currentAudio.pause(); currentAudio = null; }
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        if(sourceNode) try { sourceNode.disconnect(); } catch(e){}
        sourceNode = actx.createMediaStreamSource(stream);
        sourceNode.connect(analyser);
        ui.btnMic.classList.add('active'); ui.btnFile.classList.remove('active');
    });

    function updateAudio() {
        if(!analyser) return;
        analyser.getByteFrequencyData(dataArray);
        let b=0, m=0, h=0;
        const binCount = analyser.frequencyBinCount;
        for(let i=0; i<binCount; i++) {
            if(i < binCount*0.1) b += dataArray[i];
            else if(i < binCount*0.5) m += dataArray[i];
            else h += dataArray[i];
        }
        audioBands.bass = (b / (binCount*0.1)) / 255.0;
        audioBands.mid = (m / (binCount*0.4)) / 255.0;
        audioBands.high = (h / (binCount*0.5)) / 255.0;
        audioBands.vol = (audioBands.bass + audioBands.mid + audioBands.high) / 3.0;

        const ctx = ui.audioVis.getContext('2d');
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,320,40);
        ctx.fillStyle = '#00d2ff';
        const barW = 320 / binCount;
        for(let i=0; i<binCount; i++) {
            const h = (dataArray[i]/255) * 40;
            ctx.fillRect(i*barW, 40-h, barW, h);
        }
    }

    var modulations = [];
    var MOD_TARGETS = {
        'paramLinkA': 'Link A', 'paramLinkD': 'Link D', 'paramTwist': 'Twist', 'paramTheta': 'Joint Theta',
        'paramComplexity': 'Complexity', 'paramSymmetry': 'Symmetry',
        'paramStretch': 'Stretch', 'paramShift': 'Shift', 'paramPhase': 'Color Phase', 'paramExposure': 'Exposure',
        'paramRotZ': 'Roll (Z)', 'paramFlow': 'Flow Spd', 'paramPerturb': 'Perturb',
        'paramScan': 'CRT Scan', 'paramAbb': 'Aberration', 'paramNoise': 'Grain'
    };
    var MOD_SOURCES = { 'bass': 'Bass', 'mid': 'Mids', 'high': 'Treble', 'vol': 'Volume' };

    ui.btnAddMod.addEventListener('click', () => {
        const div = document.createElement('div');
        div.className = 'mod-item';
        div.innerHTML = `
            <div class="mod-item-header">
                <select class="mod-target">${Object.keys(MOD_TARGETS).map(k=>`<option value="${k}">${MOD_TARGETS[k]}</option>`).join('')}</select>
                <span>←</span>
                <select class="mod-source">${Object.keys(MOD_SOURCES).map(k=>`<option value="${k}">${MOD_SOURCES[k]}</option>`).join('')}</select>
                <span class="mod-remove">×</span>
            </div>
            <div class="mod-row">
                <select class="mod-curve" style="width:60px; margin-right:4px; background:#000; border:1px solid #444; color:#00d2ff; font-size:9px;">
                    <option value="lin">Lin</option><option value="sqr">Sqr</option><option value="inv">Inv</option>
                </select>
                <div class="mod-label">Offset</div><input type="number" class="mod-min mod-input" value="0.0" step="0.1">
                <div class="mod-label">Range</div><input type="number" class="mod-max mod-input" value="1.0" step="0.1">
            </div>
        `;
        div.querySelector('.mod-remove').onclick = () => {
            modulations = modulations.filter(m => m.domEl !== div);
            div.remove();
        };
        ui.modList.appendChild(div);
        modulations.push({
            domEl: div, target: div.querySelector('.mod-target'), source: div.querySelector('.mod-source'),
            curve: div.querySelector('.mod-curve'), min: div.querySelector('.mod-min'), max: div.querySelector('.mod-max')
        });
    });

    window.toggleSection = (el) => el.parentElement.classList.toggle('open');

    var canvas = document.getElementById('glcanvas');
    var gl = canvas.getContext('webgl2', { powerPreference: "high-performance", alpha: false });
    if (!gl) document.body.innerHTML = "WebGL 2 Not Supported";

    var createProgram = (vs, fs) => {
        const p = gl.createProgram();
        const add = (type, src) => {
            const s = gl.createShader(type);
            gl.shaderSource(s, src); gl.compileShader(s);
            if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
            gl.attachShader(p, s);
        };
        add(gl.VERTEX_SHADER, vs); add(gl.FRAGMENT_SHADER, fs);
        gl.linkProgram(p);
        return p;
    };

    var vsSrc = document.getElementById('vs').innerText;
    var pFractal = createProgram(vsSrc, document.getElementById('fs-fractal').innerText);
    var pPost = createProgram(vsSrc, document.getElementById('fs-post').innerText);

    var texRender = gl.createTexture();
    var fbo = gl.createFramebuffer();
    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);

    function setupTex(t, w, h) {
        gl.bindTexture(gl.TEXTURE_2D, t);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }

    var getLoc = (p, name) => gl.getUniformLocation(p, name);
    var U = {
        f: {
            res: getLoc(pFractal, 'uRes'), camPos: getLoc(pFractal, 'uCamPos'),
            camFwd: getLoc(pFractal, 'uCamFwd'), camRight: getLoc(pFractal, 'uCamRight'), camUp: getLoc(pFractal, 'uCamUp'),
            colorMode: getLoc(pFractal, 'uColorMode'), 
            uParams: getLoc(pFractal, 'uParams'), uSpatialIdx: getLoc(pFractal, 'uSpatialIdx'),
            stretch: getLoc(pFractal, 'uStretch'), shift: getLoc(pFractal, 'uShift'), density: getLoc(pFractal, 'uDensity'),
            steps: getLoc(pFractal, 'uSteps'), correct: getLoc(pFractal, 'uCorrectStr'),
            rayMax: getLoc(pFractal, 'uRayStepsMax'), time: getLoc(pFractal, 'uTime'), phase: getLoc(pFractal, 'uPhase'),
            colA: getLoc(pFractal, 'uColA'), colB: getLoc(pFractal, 'uColB'), colC: getLoc(pFractal, 'uColC'),
            exp: getLoc(pFractal, 'uExp'), con: getLoc(pFractal, 'uCon'), sat: getLoc(pFractal, 'uSat')
        },
        p: { tex: getLoc(pPost, 'uTex'), res: getLoc(pPost, 'uRes'), scan: getLoc(pPost, 'uScan'), abb: getLoc(pPost, 'uAbb'), noise: getLoc(pPost, 'uNoise'),
             fluid: getLoc(pPost, 'uFluid'), grid: getLoc(pPost, 'uGridSize'), flow: getLoc(pPost, 'uFlowSpd'),
             perturb: getLoc(pPost, 'uPerturb'), time: getLoc(pPost, 'uTime'), despeckle: getLoc(pPost, 'uDespeckleStr') }
    };

    var camPos = { x: 0, y: 0, z: 6 };
    var camRot = { x: -0.1, y: 3.14159, z: 0 };
    var keys = {}, isDrag = false;
    var currentTexW = 0, currentTexH = 0;
    var values = {};

    window.onkeydown = e => keys[e.key.toLowerCase()] = true;
    window.onkeyup = e => keys[e.key.toLowerCase()] = false;
    window.onmousedown = e => { if(e.target.closest('#ui-container')) return; isDrag=true; };
    window.onmouseup = () => isDrag=false;
    window.onmousemove = e => { 
        if(isDrag) { 
            camRot.y -= e.movementX * 0.003; 
            camRot.x -= e.movementY * 0.003; 
            camRot.x = Math.max(-1.5, Math.min(1.5, camRot.x));
        } 
    };

    function hexToRgb(hex) {
        let r = parseInt(hex.slice(1,3),16)/255, g = parseInt(hex.slice(3,5),16)/255, b = parseInt(hex.slice(5,7),16)/255;
        return [r,g,b];
    }

    function loop(time) {
        updateAudio();
        
        // 1. Get Base Values & Modulation
        for(let k in MOD_TARGETS) values[k] = parseFloat(ui.params[k].value);
        for(let i = 0; i < modulations.length; i++) {
            const mod = modulations[i];
            const target = mod.target.value;
            const source = mod.source.value; 
            let audioVal = audioBands[source] || 0;
            const curveType = mod.curve.value;
            if (curveType === 'sqr') audioVal *= audioVal;
            else if (curveType === 'inv') audioVal = 1.0 - audioVal;
            values[target] += parseFloat(mod.min.value) + (parseFloat(mod.max.value) * audioVal);
        }

        // Handle Spatial Mapping UI State
        const spatialIdx = parseInt(ui.spatialParam.value);
        // Reset all to enabled
        for(let i=0; i<=5; i++) {
            const el = document.getElementById('group-' + SPATIAL_MAP[i]);
            if(el) el.classList.remove('disabled');
        }
        // Disable selected
        if(spatialIdx >= 0) {
            const el = document.getElementById('group-' + SPATIAL_MAP[spatialIdx]);
            if(el) el.classList.add('disabled');
        }

        // 2. Update Camera
        if(!isDrag) camRot.z = values['paramRotZ'];
        const cx = Math.cos(camRot.x), sx = Math.sin(camRot.x);
        const cy = Math.cos(camRot.y), sy = Math.sin(camRot.y);
        const cz = Math.cos(camRot.z), sz = Math.sin(camRot.z);
        let fwd = { x: Math.sin(camRot.y) * Math.cos(camRot.x), y: Math.sin(camRot.x), z: Math.cos(camRot.y) * Math.cos(camRot.x) };
        let r0 = { x: Math.cos(camRot.y), y: 0, z: -Math.sin(camRot.y) };
        let u0 = { x: r0.y*fwd.z - r0.z*fwd.y, y: r0.z*fwd.x - r0.x*fwd.z, z: r0.x*fwd.y - r0.y*fwd.x };
        let right = { x: r0.x * cz - u0.x * sz, y: r0.y * cz - u0.y * sz, z: r0.z * cz - u0.z * sz };
        let up = { x: u0.x * cz + r0.x * sz, y: u0.y * cz + r0.y * sz, z: u0.z * cz + r0.z * sz };
        
        let isMoving = isDrag || Object.values(keys).some(k=>k);
        if(isMoving) {
            const s=0.05;
            if(keys.w){camPos.x+=fwd.x*s;camPos.y+=fwd.y*s;camPos.z+=fwd.z*s;}
            if(keys.s){camPos.x-=fwd.x*s;camPos.y-=fwd.y*s;camPos.z-=fwd.z*s;}
            if(keys.d){camPos.x+=right.x*s;camPos.y+=right.y*s;camPos.z+=right.z*s;}
            if(keys.a){camPos.x-=right.x*s;camPos.y-=right.y*s;camPos.z-=right.z*s;}
            if(keys[' '])camPos.y+=s; if(keys.shift)camPos.y-=s;
        }

        // 3. Resolution & Texture
        const lowSpec = ui.params['paramLowSpec'].checked;
        const fluidEnabled = ui.params['paramFluid'].checked;
        const dpr = Math.min(window.devicePixelRatio, 2.0);
        const displayW = Math.floor(window.innerWidth * dpr);
        const displayH = Math.floor(window.innerHeight * dpr);
        let renderW, renderH;
        
        if (fluidEnabled) {
            const grid = parseFloat(ui.params['paramGrid'].value);
            const aspect = window.innerWidth / window.innerHeight;
            renderH = Math.floor(Math.max(grid * 2.0, 64)); 
            renderW = Math.floor(renderH * aspect);
        } else {
            const resScale = lowSpec ? 0.5 : parseFloat(ui.params['paramRes'].value);
            renderW = Math.floor(displayW * resScale);
            renderH = Math.floor(displayH * resScale);
        }
        
        if(canvas.width !== displayW || canvas.height !== displayH) {
            canvas.width = displayW; canvas.height = displayH;
        }
        if(Math.abs(currentTexW - renderW) > 1 || Math.abs(currentTexH - renderH) > 1) {
            setupTex(texRender, renderW, renderH);
            currentTexW = renderW; currentTexH = renderH;
        }

        gl.viewport(0,0, renderW, renderH);
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        const attr = loc => { gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0); };

        // PASS 1: Raymarch
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texRender, 0);
        gl.useProgram(pFractal);
        attr(gl.getAttribLocation(pFractal, 'position'));
        
        gl.uniform2f(U.f.res, renderW, renderH);
        gl.uniform3f(U.f.camPos, camPos.x, camPos.y, camPos.z);
        gl.uniform3f(U.f.camFwd, fwd.x, fwd.y, fwd.z);
        gl.uniform3f(U.f.camRight, right.x, right.y, right.z);
        gl.uniform3f(U.f.camUp, up.x, up.y, up.z);
        
        // Pass Parameters Array
        gl.uniform1fv(U.f.uParams, new Float32Array([
            values['paramLinkA'], values['paramLinkD'], values['paramTwist'],
            values['paramTheta'], values['paramComplexity'], values['paramSymmetry']
        ]));
        gl.uniform1i(U.f.uSpatialIdx, spatialIdx);
        
        gl.uniform1i(U.f.colorMode, parseInt(ui.params['colorMode'].value));
        gl.uniform1f(U.f.stretch, values['paramStretch']);
        gl.uniform1f(U.f.shift, values['paramShift']);
        gl.uniform1f(U.f.density, ui.params['paramDensity'].value);
        gl.uniform1i(U.f.steps, parseInt(ui.params['paramSteps'].value));
        gl.uniform1f(U.f.correct, parseFloat(ui.params['paramCorrect'].value));
        gl.uniform1i(U.f.rayMax, parseInt(ui.params['paramRaySteps'].value));
        gl.uniform1f(U.f.time, time * 0.001);
        gl.uniform1f(U.f.phase, values['paramPhase']);
        gl.uniform3fv(U.f.colA, hexToRgb(ui.params['col-a'].value));
        gl.uniform3fv(U.f.colB, hexToRgb(ui.params['col-b'].value));
        gl.uniform3fv(U.f.colC, hexToRgb(ui.params['col-c'].value));
        gl.uniform1f(U.f.exp, values['paramExposure']);
        gl.uniform1f(U.f.con, parseFloat(ui.params['paramContrast'].value)); 
        gl.uniform1f(U.f.sat, parseFloat(ui.params['paramSat'].value));
        
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        // PASS 2: Post
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, displayW, displayH);
        gl.useProgram(pPost);
        attr(gl.getAttribLocation(pPost, 'position'));
        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texRender);
        gl.uniform1i(U.p.tex, 0);
        gl.uniform2f(U.p.res, renderW, renderH); 
        gl.uniform1f(U.p.scan, values['paramScan']);
        gl.uniform1f(U.p.abb, values['paramAbb']);
        gl.uniform1f(U.p.noise, values['paramNoise']);
        gl.uniform1i(U.p.fluid, fluidEnabled ? 1 : 0);
        gl.uniform1f(U.p.grid, parseFloat(ui.params['paramGrid'].value));
        gl.uniform1f(U.p.flow, values['paramFlow']);
        gl.uniform1f(U.p.perturb, values['paramPerturb']);
        gl.uniform1f(U.p.time, time * 0.001);
        gl.uniform1f(U.p.despeckle, parseFloat(ui.params['paramDespeckle'].value));

        gl.drawArrays(gl.TRIANGLES, 0, 3);

        ui.fps.innerText = Math.round(1000 / (performance.now() - lastTime));
        lastTime = performance.now();
        frameCount++;
        requestAnimationFrame(loop);
    }
    let lastTime = 0;
    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
