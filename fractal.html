<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Smooth 3D Newton Iso-Surface â€“ Optimized</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #050608;
    color: #ddd;
    font-family: system-ui, sans-serif;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(10, 10, 16, 0.9);
    padding: 10px 12px;
    border-radius: 8px;
    border: 1px solid rgba(200,200,255,0.2);
    z-index: 10;
    font-size: 13px;
  }
  #ui label {
    display: block;
    margin-bottom: 4px;
  }
  #ui input[type=range] {
    width: 180px;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<div id="ui">
  <label>
    n range (along z):
    <input id="nRange" type="range" min="0.1" max="6.0" step="0.01" value="3.0">
    <span id="nRangeValue">3.00</span>
  </label>
  <label>
    iso level (0 = deep basins, 1 = near boundary):
    <input id="isoLevel" type="range" min="0" max="1" step="0.01" value="0.55">
    <span id="isoLevelValue">0.55</span>
  </label>
  <label>
    q parameter:
    <input id="qParam" type="range" min="-2.0" max="2.0" step="0.01" value="0.0">
    <span id="qParamValue">0.00</span>
  </label>
  <label>
    p parameter:
    <input id="pParam" type="range" min="-2.0" max="2.0" step="0.01" value="0.0">
    <span id="pParamValue">0.00</span>
  </label>
  <label>
    animation speed:
    <input id="speedParam" type="range" min="0.1" max="5.0" step="0.1" value="2.0">
    <span id="speedParamValue">2.0</span>
  </label>
  <label>
    FPS target:
    <input id="fpsTarget" type="range" min="15" max="60" step="5" value="30">
    <span id="fpsTargetValue">30</span>
  </label>
  <label>
    function:
    <select id="functionSelect" style="width:180px; padding:2px; background:#223; color:#ddd; border:1px solid #667; border-radius:3px;">
      <option value="0">sin(nwÂ²+q)Â·w + cos(pw) - w + 1</option>
      <option value="1">nÂ·wÂ³ - qÂ·wÂ² + p</option>
      <option value="2">Î¶-approx: w^n + w^(-q) + p</option>
      <option value="3">sin(t)(wÂ³-1) + cos(t)(wÂ·sin(w)-wÂ²-q)</option>
    </select>
  </label>
  <label>
    transparent color:
    <input id="colorPicker" type="color" value="#000000">
  </label>
  <label>
    transparency tolerance:
    <input id="toleranceParam" type="range" min="0.0" max="1.0" step="0.01" value="0.1">
    <span id="toleranceValue">0.10</span>
  </label>
  <label>
    color scheme:
    <select id="colorScheme" style="width:180px; padding:2px; background:#223; color:#ddd; border:1px solid #667; border-radius:3px;">
      <option value="0">Angle-based (rainbow)</option>
      <option value="1">Depth gradient</option>
      <option value="2">Iterations heatmap</option>
      <option value="3">Solid color</option>
    </select>
  </label>
  <label>
    solid color:
    <input id="solidColor" type="color" value="#ff6600">
  </label>
  <label>
    shading mode:
    <select id="shadingMode" style="width:180px; padding:2px; background:#223; color:#ddd; border:1px solid #667; border-radius:3px;">
      <option value="0">Flat</option>
      <option value="1">Normal-based lighting</option>
      <option value="2">Ambient occlusion</option>
    </select>
  </label>
  <label>
    brightness:
    <input id="brightness" type="range" min="0.5" max="2.0" step="0.1" value="1.0">
    <span id="brightnessValue">1.0</span>
  </label>
  <label>
    contrast:
    <input id="contrast" type="range" min="0.5" max="2.0" step="0.1" value="1.0">
    <span id="contrastValue">1.0</span>
  </label>
  <label>
    background color:
    <input id="bgColor" type="color" value="#050608">
  </label>
  <label>
    fog amount:
    <input id="fogAmount" type="range" min="0.0" max="1.0" step="0.05" value="0.3">
    <span id="fogAmountValue">0.30</span>
  </label>
  <div style="margin-top:8px;">
    <button id="animateBtn" style="padding:4px 12px; cursor:pointer; border-radius:4px; background:#334; color:#ddd; border:1px solid #667;">
      Toggle Sin Animation
    </button>
  </div>
  
  <!-- Audio Control Section -->
  <div style="margin-top:12px; padding-top:8px; border-top:1px solid rgba(200,200,255,0.2);">
    <div style="font-weight:bold; margin-bottom:6px;">ðŸŽµ Audio Reactive VJ</div>
    <input type="file" id="audioFile" accept="audio/*" style="font-size:11px; margin-bottom:6px;">
    <div style="margin-bottom:6px;">
      <button id="audioPlayBtn" style="padding:4px 12px; cursor:pointer; border-radius:4px; background:#334; color:#ddd; border:1px solid #667; font-size:11px;" disabled>
        Play
      </button>
    </div>
    
    <label style="font-size:11px;">
      Global smoothing: <input id="audioSmoothing" type="range" min="0.0" max="0.95" step="0.05" value="0.3" style="width:100px;">
      <span id="audioSmoothingValue">0.30</span>
    </label>
    
    <div style="font-size:11px; margin-top:6px; padding:4px; background:rgba(0,0,0,0.3); border-radius:3px;">
      <div style="margin-bottom:3px;">Bass â†’ q (kick)</div>
      <label style="font-size:10px; display:inline-block; margin-right:8px;">
        Amt: <input id="audioToQ" type="range" min="-10.0" max="10.0" step="0.1" value="3.0" style="width:80px;">
        <span id="audioToQValue">3.0</span>
      </label>
      <label style="font-size:10px; display:inline-block;">
        Mode: <select id="audioModeQ" style="font-size:10px; background:#223; color:#ddd; border:1px solid #667;">
          <option value="add">Add</option>
          <option value="mult">Multiply</option>
          <option value="osc">Oscillate</option>
        </select>
      </label>
    </div>
    
    <div style="font-size:11px; margin-top:4px; padding:4px; background:rgba(0,0,0,0.3); border-radius:3px;">
      <div style="margin-bottom:3px;">Mid â†’ p (snare/vocals)</div>
      <label style="font-size:10px; display:inline-block; margin-right:8px;">
        Amt: <input id="audioToP" type="range" min="-10.0" max="10.0" step="0.1" value="2.0" style="width:80px;">
        <span id="audioToPValue">2.0</span>
      </label>
      <label style="font-size:10px; display:inline-block;">
        Mode: <select id="audioModeP" style="font-size:10px; background:#223; color:#ddd; border:1px solid #667;">
          <option value="add">Add</option>
          <option value="mult">Multiply</option>
          <option value="osc">Oscillate</option>
        </select>
      </label>
    </div>
    
    <div style="font-size:11px; margin-top:4px; padding:4px; background:rgba(0,0,0,0.3); border-radius:3px;">
      <div style="margin-bottom:3px;">Treble â†’ n (hi-hats)</div>
      <label style="font-size:10px; display:inline-block; margin-right:8px;">
        Amt: <input id="audioToN" type="range" min="-10.0" max="10.0" step="0.1" value="2.5" style="width:80px;">
        <span id="audioToNValue">2.5</span>
      </label>
      <label style="font-size:10px; display:inline-block;">
        Mode: <select id="audioModeN" style="font-size:10px; background:#223; color:#ddd; border:1px solid #667;">
          <option value="add">Add</option>
          <option value="mult">Multiply</option>
          <option value="osc">Oscillate</option>
        </select>
      </label>
    </div>
    
    <div style="font-size:11px; margin-top:4px; padding:4px; background:rgba(0,0,0,0.3); border-radius:3px;">
      <div style="margin-bottom:3px;">Bass â†’ iso</div>
      <label style="font-size:10px; display:inline-block; margin-right:8px;">
        Amt: <input id="audioToIso" type="range" min="-2.0" max="2.0" step="0.01" value="0.3" style="width:80px;">
        <span id="audioToIsoValue">0.30</span>
      </label>
      <label style="font-size:10px; display:inline-block;">
        Mode: <select id="audioModeIso" style="font-size:10px; background:#223; color:#ddd; border:1px solid #667;">
          <option value="add">Add</option>
          <option value="mult">Multiply</option>
          <option value="osc">Oscillate</option>
        </select>
      </label>
    </div>
    
    <div style="margin-top:6px; font-size:11px;">
      <label style="font-size:11px;">
        <input type="checkbox" id="beatReactive" checked> Beat-reactive flash
      </label>
      <label style="font-size:10px; margin-left:10px;">
        Threshold: <input id="beatThreshold" type="range" min="0.3" max="0.9" step="0.05" value="0.6" style="width:60px;">
        <span id="beatThresholdValue">0.60</span>
      </label>
    </div>
    
    <label style="font-size:11px; margin-top:4px;">
      Auto-gain (RMS): <input id="autoGain" type="range" min="0.5" max="3.0" step="0.1" value="1.5" style="width:100px;">
      <span id="autoGainValue">1.5</span>
    </label>
    <label style="font-size:11px; margin-top:2px;">
      Manual boost: <input id="manualGain" type="range" min="0.5" max="5.0" step="0.1" value="1.0" style="width:100px;">
      <span id="manualGainValue">1.0</span>
    </label>
  </div>
  
  <!-- MIDI Control Section -->
  <div style="margin-top:12px; padding-top:8px; border-top:1px solid rgba(200,200,255,0.2);">
    <div style="font-weight:bold; margin-bottom:6px;">ðŸŽ¹ MIDI Control</div>
    <button id="midiEnableBtn" style="padding:4px 12px; cursor:pointer; border-radius:4px; background:#334; color:#ddd; border:1px solid #667; margin-bottom:6px;">
      Enable MIDI
    </button>
    <div id="midiStatus" style="font-size:11px; opacity:0.7; margin-bottom:6px;">Not connected</div>
    <label style="font-size:12px;">
      <input type="checkbox" id="midiLearnMode"> Learn Mode
    </label>
    <div id="midiMappings" style="font-size:11px; opacity:0.7; margin-top:6px; max-height:100px; overflow-y:auto;"></div>
  </div>
  
  <div style="margin-top:6px; opacity:0.8">
    z axis = parameter n(z) (smooth)<br>
    Click canvas â†’ mouse look<br>
    WASD = move, Q/E = down/up
  </div>
</div>
<canvas id="glcanvas"></canvas>

<!-- Vertex shader -->
<script id="vs" type="x-shader/x-vertex">
attribute vec2 aPosition;
void main() {
    gl_Position = vec4(aPosition, 0.0, 1.0);
}
</script>

<!-- Fragment shader -->
<script id="fs" type="x-shader/x-fragment">
precision highp float;

uniform vec2  uResolution;
uniform vec3  uCamPos;
uniform vec3  uCamForward;
uniform vec3  uCamRight;
uniform vec3  uCamUp;
uniform float uFov;        // tan(FOV/2)
uniform float uBoxR;       // half-size of cube in x,y,z
uniform float uNRange;     // parameter range for n(z)
uniform float uIsoLevel;   // 0..1 iso level on smooth field
uniform float uQ;          // q parameter
uniform float uP;          // p parameter
uniform float uTime;       // time for animated functions
uniform vec3  uTransparentColor; // color to make transparent
uniform float uTolerance;  // tolerance for color matching
uniform int   uFunction;   // which function to use
uniform int   uColorScheme; // which color scheme to use
uniform vec3  uSolidColor;  // solid color option
uniform int   uShadingMode; // shading mode
uniform float uBrightness;  // brightness multiplier
uniform float uContrast;    // contrast multiplier
uniform vec3  uBgColor;     // background color
uniform float uFogAmount;   // fog amount

// ------------- Complex ops: z = vec2(x,y) -------------

vec2 cMul(vec2 a, vec2 b) {
    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
}

vec2 cDiv(vec2 a, vec2 b) {
    float d = dot(b,b);
    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y) / (d + 1e-8);
}

vec2 cSqr(vec2 z) {
    return cMul(z,z);
}

vec2 cSin(vec2 z) {
    float a = z.x;
    float b = z.y;
    float sh = 0.5*(exp(b) - exp(-b));
    float ch = 0.5*(exp(b) + exp(-b));
    return vec2(sin(a)*ch, cos(a)*sh);
}

vec2 cCos(vec2 z) {
    float a = z.x;
    float b = z.y;
    float sh = 0.5*(exp(b) - exp(-b));
    float ch = 0.5*(exp(b) + exp(-b));
    return vec2(cos(a)*ch, -sin(a)*sh);
}

vec2 cPow(vec2 z, float n) {
    float r = length(z);
    float theta = atan(z.y, z.x);
    float rn = pow(r, n);
    return vec2(rn * cos(n * theta), rn * sin(n * theta));
}

vec2 cLog(vec2 z) {
    float r = length(z);
    float theta = atan(z.y, z.x);
    return vec2(log(r), theta);
}

// ------------- Color from complex angle -------------

vec3 angleColor(vec2 z) {
    float ang = atan(z.y, z.x); // [-pi, pi]
    float u = (ang + 3.14159265) / (2.0 * 3.14159265); // [0,1]
    return vec3(
        0.5 + 0.5*cos(6.2831*(u + 0.0)),
        0.5 + 0.5*cos(6.2831*(u + 0.33)),
        0.5 + 0.5*cos(6.2831*(u + 0.66))
    );
}

// ------------- Smooth Newton field -------------
// f(w; n, q, p) = sin(n w^2 + q) * w + cos(p w) - w + 1
// We do K fixed iterations and build a smooth scalar
// phi = normalized average log|f(w_k; n, q, p)|.

const int K = 10; // balanced iterations for performance and quality

void evalField(vec3 p, out float phiNorm, out vec3 baseColor, out int iterCount, out float depth) {
    float R = uBoxR;

    // map xy in cube [-R,R] into something like [-2.5,2.5]^2
    float scaleXY = 2.5;
    vec2 w = vec2(p.x, p.y) / R * scaleXY;

    // smooth parameter - use distance from origin instead of just z
    // This reduces artifacts when viewing from the side
    float dist = length(p) / (R * 1.732); // normalize by diagonal
    float n = 1.0 + (dist - 0.5) * uNRange;

    vec2 wCurr = w;
    float acc = 0.0;
    int   steps = 0;

    for (int i = 0; i < K; ++i) {
        vec2 f, fp;
        
        if (uFunction == 0) {
            // Function 0: sin(n w^2 + q) * w + cos(p w) - w + 1
            vec2 w2  = cSqr(wCurr);
            vec2 arg = w2 * n + vec2(uQ, 0.0);
            vec2 s   = cSin(arg);
            vec2 c   = cCos(arg);
            
            vec2 arg2 = wCurr * uP;
            vec2 cos_pw = cCos(arg2);
            vec2 sin_pw = cSin(arg2);

            f = cMul(s, wCurr) + cos_pw - wCurr + vec2(1.0, 0.0);

            // f' = g'(w)*w + g(w) + h'(w) - 1
            vec2 two_n_w = vec2(2.0*n, 0.0) * wCurr;
            vec2 gPrime  = cMul(c, two_n_w);
            vec2 hPrime  = cMul(sin_pw, vec2(-uP, 0.0));
            fp = cMul(gPrime, wCurr) + s + hPrime - vec2(1.0, 0.0);
        } else if (uFunction == 1) {
            // Function 1: n*w^3 - q*w^2 + p
            vec2 w2 = cSqr(wCurr);
            vec2 w3 = cMul(w2, wCurr);
            f = vec2(n, 0.0) * w3 - vec2(uQ, 0.0) * w2 + vec2(uP, 0.0);
            
            // f' = 3*n*w^2 - 2*q*w
            fp = vec2(3.0 * n, 0.0) * w2 - vec2(2.0 * uQ, 0.0) * wCurr;
        } else if (uFunction == 2) {
            // Function 2: zeta-approximation: w^n + w^(-q) + p
            vec2 wn = cPow(wCurr, n);
            vec2 winvq = cPow(wCurr, -uQ);
            f = wn + winvq + vec2(uP, 0.0);
            
            // f' = n*w^(n-1) - q*w^(-q-1)
            vec2 term1 = vec2(n, 0.0) * cPow(wCurr, n - 1.0);
            vec2 term2 = vec2(-uQ, 0.0) * cPow(wCurr, -uQ - 1.0);
            fp = term1 + term2;
        } else if (uFunction == 3) {
            // Function 3: sin(t)(wÂ³-1) + cos(t)(wÂ·sin(w)-wÂ²-q)
            // Time-varying coefficients with parameters mixed in
            float st = sin(uTime);
            float ct = cos(uTime);
            
            vec2 w2 = cSqr(wCurr);
            vec2 w3 = cMul(w2, wCurr);
            
            // First term: sin(t) * (wÂ³ - 1)
            vec2 term1 = vec2(st, 0.0) * (w3 - vec2(1.0, 0.0));
            
            // Second term: cos(t) * (wÂ·sin(w) - wÂ² - q)
            vec2 sinW = cSin(wCurr);
            vec2 wSinW = cMul(wCurr, sinW);
            vec2 innerTerm = wSinW - w2 - vec2(uQ, 0.0);
            vec2 term2 = vec2(ct, 0.0) * innerTerm;
            
            // Add p parameter to final result
            f = term1 + term2 + vec2(uP, 0.0);
            
            // Derivative: sin(t)(3wÂ²) + cos(t)(sin(w) + wÂ·cos(w) - 2w)
            vec2 cosW = cCos(wCurr);
            vec2 wCosW = cMul(wCurr, cosW);
            vec2 fp1 = vec2(st, 0.0) * vec2(3.0, 0.0) * w2;
            vec2 fp2Inner = sinW + wCosW - vec2(2.0, 0.0) * wCurr;
            vec2 fp2 = vec2(ct, 0.0) * fp2Inner;
            fp = fp1 + fp2;
        } else {
            // Function 2 fallback (old else case)
            vec2 wn = cPow(wCurr, n);
            vec2 winvq = cPow(wCurr, -uQ);
            f = wn + winvq + vec2(uP, 0.0);
            
            // f' = n*w^(n-1) - q*w^(-q-1)
            vec2 term1 = vec2(n, 0.0) * cPow(wCurr, n - 1.0);
            vec2 term2 = vec2(-uQ, 0.0) * cPow(wCurr, -uQ - 1.0);
            fp = term1 + term2;
        }

        float err = length(f);
        acc += log(err + 1e-6);
        steps = i + 1;

        float denom = dot(fp, fp);
        if (denom < 1e-10) {
            break;
        }
        
        // Check if converged
        if (err < 1e-8) {
            break;
        }

        vec2 step = cDiv(f, fp);
        wCurr = wCurr - step;
    }

    if (steps == 0) steps = 1;
    float avgLog = acc / float(steps);

    // Normalize avgLog into [0,1] by an affine map + clamp.
    // Heuristic range; tweak constants for contrast.
    float phi = (avgLog + 6.0) / 8.0;
    phi = clamp(phi, 0.0, 1.0);

    phiNorm = phi;
    baseColor = angleColor(wCurr);
    iterCount = steps;
    depth = dist;
}

// Apply color scheme
vec3 applyColorScheme(vec3 angleCol, int iters, float depth) {
    if (uColorScheme == 0) {
        // Angle-based (rainbow)
        return angleCol;
    } else if (uColorScheme == 1) {
        // Depth gradient (blue to red)
        float t = clamp(depth, 0.0, 1.0);
        return mix(vec3(0.1, 0.3, 0.8), vec3(0.9, 0.2, 0.1), t);
    } else if (uColorScheme == 2) {
        // Iterations heatmap
        float t = float(iters) / float(K);
        vec3 cold = vec3(0.0, 0.0, 0.5);
        vec3 warm = vec3(1.0, 0.9, 0.0);
        vec3 hot = vec3(1.0, 0.1, 0.0);
        return mix(mix(cold, warm, t * 2.0), hot, max(0.0, t * 2.0 - 1.0));
    } else {
        // Solid color
        return uSolidColor;
    }
}

// ------------- Rayâ€“box intersection (axis-aligned cube) -------------

bool intersectBox(vec3 ro, vec3 rd, float R,
                  out float t0, out float t1) {
    vec3 invD = 1.0 / rd;

    vec3 tMin = (vec3(-R) - ro) * invD;
    vec3 tMax = (vec3( R) - ro) * invD;

    vec3 t1v = min(tMin, tMax);
    vec3 t2v = max(tMin, tMax);

    t0 = max(max(t1v.x, t1v.y), max(t1v.z, 0.0));
    t1 = min(min(t2v.x, t2v.y), t2v.z);

    return t1 > t0;
}

// ------------- Iso-surface raymarch on smooth phiNorm -------------

const int   MAX_RAY_STEPS = 120;  // Increased for better sampling
const int   BINARY_STEPS  = 6;    // More refinement steps

// Directional derivative for head-on detection
float directionalDerivative(vec3 p, vec3 dir) {
    float h = 0.01;
    float phi0, phi1;
    vec3 tmpC;
    int tmpI;
    float tmpD;
    
    evalField(p + dir * h, phi0, tmpC, tmpI, tmpD);
    evalField(p - dir * h, phi1, tmpC, tmpI, tmpD);
    
    return (phi0 - phi1) / (2.0 * h);
}

void main() {
    vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;
    uv.x *= uResolution.x / uResolution.y;

    vec3 dir = normalize(
        uCamForward +
        uv.x * uFov * uCamRight +
        uv.y * uFov * uCamUp
    );
    vec3 ro = uCamPos;

    // Start raymarching from camera with closer view distance
    float t0 = 0.01;  // Small offset to avoid camera position artifacts
    float t1 = 10.0;  // View distance

    bool  hit = false;
    float hitT = 0.0;
    vec3  hitColor = vec3(0.0);

    float prevPhi = 0.0;
    vec3  prevColor = vec3(0.0);
    float prevT = t0;
    bool  havePrev = false;
    int   prevIters = 0;
    float prevDepth = 0.0;
    
    float t = t0;

    for (int i = 0; i < MAX_RAY_STEPS; ++i) {
        if (t > t1) break;
        vec3 p = ro + dir * t;

        float phi;
        vec3  c;
        int   iters;
        float depth;
        evalField(p, phi, c, iters, depth);

        if (havePrev) {
            float g0 = prevPhi - uIsoLevel;
            float g1 = phi     - uIsoLevel;
            if (g0 * g1 < 0.0) {
                // binary search in [prevT, t]
                float a = prevT;
                float b = t;
                float phiA = prevPhi;
                float phiB = phi;
                vec3  colA = prevColor;
                vec3  colB = c;
                float midT = 0.0;
                vec3  midC = c;
                int   midIters = iters;
                float midDepth = depth;

                for (int j = 0; j < BINARY_STEPS; ++j) {
                    midT = 0.5 * (a + b);
                    vec3 mp = ro + dir * midT;
                    float phiM;
                    vec3  colM;
                    int   itersM;
                    float depthM;
                    evalField(mp, phiM, colM, itersM, depthM);

                    float gA = phiA - uIsoLevel;
                    float gM = phiM - uIsoLevel;

                    if (gA * gM <= 0.0) {
                        b = midT;
                        phiB = phiM;
                        colB = colM;
                        midIters = itersM;
                        midDepth = depthM;
                    } else {
                        a = midT;
                        phiA = phiM;
                        colA = colM;
                    }
                    midC = colM;
                }

                hit = true;
                hitT = midT;
                hitColor = applyColorScheme(midC, midIters, midDepth);
                break;
            }
        }

        prevPhi = phi;
        prevColor = c;
        prevT   = t;
        prevIters = iters;
        prevDepth = depth;
        havePrev = true;
        
        // Adaptive step sizing based on field gradient and ray direction
        float gradMag = abs(phi - prevPhi) / max(t - prevT, 0.001);
        float dirDeriv = abs(directionalDerivative(p, dir));
        
        // Smaller steps when:
        // 1. Near the iso-surface (small |phi - uIsoLevel|)
        // 2. Head-on approach (small dirDeriv)
        // 3. Steep gradient (large gradMag)
        
        float distToIso = abs(phi - uIsoLevel);
        float headOnFactor = max(dirDeriv, 0.2); // Clamp to avoid too-small steps
        
        // Base step from distance to iso-surface
        float baseStep = distToIso * 0.8;
        
        // Reduce step when head-on
        float stepSize = baseStep * headOnFactor;
        
        // Clamp to reasonable range
        stepSize = clamp(stepSize, 0.005, 0.15);
        
        t += stepSize;
    }

    if (!hit) {
        float v = 0.3 + 0.2 * dir.y;
        vec3 bg = uBgColor * v;
        gl_FragColor = vec4(bg, 1.0);
        return;
    }

    // Normal via finite differences on phiNorm
    vec3 pHit = ro + dir * hitT;
    float eps = 0.002;  // Slightly larger for performance

    float phiC; vec3 tmpC; int tmpI; float tmpD;
    evalField(pHit, phiC, tmpC, tmpI, tmpD);

    // Use central differences for better accuracy with fewer samples
    float phiX, phiY, phiZ;
    evalField(pHit + vec3(eps, 0.0, 0.0), phiX, tmpC, tmpI, tmpD);
    evalField(pHit - vec3(eps, 0.0, 0.0), phiC, tmpC, tmpI, tmpD);
    float dx = phiX - phiC;
    
    evalField(pHit + vec3(0.0, eps, 0.0), phiY, tmpC, tmpI, tmpD);
    evalField(pHit - vec3(0.0, eps, 0.0), phiC, tmpC, tmpI, tmpD);
    float dy = phiY - phiC;
    
    evalField(pHit + vec3(0.0, 0.0, eps), phiZ, tmpC, tmpI, tmpD);
    evalField(pHit - vec3(0.0, 0.0, eps), phiC, tmpC, tmpI, tmpD);
    float dz = phiZ - phiC;

    vec3 grad = vec3(dx, dy, dz);
    
    // Ensure gradient is not degenerate
    float gradLen = length(grad);
    vec3 N = gradLen > 1e-6 ? grad / gradLen : -dir;

    vec3 baseColor = hitColor;
    vec3 finalColor = baseColor;

    // Apply shading modes
    if (uShadingMode == 1) {
        // Normal-based lighting
        vec3 L = normalize(vec3(0.6, 0.7, 0.4));
        float ndotl = max(dot(N, L), 0.0);
        float rim   = pow(1.0 - max(dot(N, -dir), 0.0), 2.0);

        vec3 ambient = 0.22 * baseColor;
        vec3 diffuse = 0.85 * baseColor * ndotl;
        vec3 rimLight = 0.25 * vec3(1.0) * rim;
        
        finalColor = ambient + diffuse + rimLight;
    } else if (uShadingMode == 2) {
        // Ambient occlusion approximation
        float ao = 1.0;
        float stepSize = 0.05;
        for (int i = 1; i <= 4; i++) {
            vec3 samplePos = pHit + N * stepSize * float(i);
            float samplePhi;
            evalField(samplePos, samplePhi, tmpC, tmpI, tmpD);
            ao -= (1.0 / pow(2.0, float(i))) * max(0.0, uIsoLevel - samplePhi);
        }
        ao = clamp(ao, 0.0, 1.0);
        
        vec3 L = normalize(vec3(0.6, 0.7, 0.4));
        float ndotl = max(dot(N, L), 0.0);
        
        vec3 ambient = 0.15 * baseColor * ao;
        vec3 diffuse = 0.95 * baseColor * ndotl * ao;
        
        finalColor = ambient + diffuse;
    }
    // else flat shading (uShadingMode == 0), finalColor = baseColor
    
    // Apply brightness and contrast
    finalColor = (finalColor - 0.5) * uContrast + 0.5; // Contrast
    finalColor = finalColor * uBrightness; // Brightness
    
    // Apply fog based on distance
    float fogFactor = exp(-hitT * uFogAmount * 0.5);
    fogFactor = clamp(fogFactor, 0.0, 1.0);
    float v = 0.3 + 0.2 * dir.y;
    vec3 bgColor = uBgColor * v;
    finalColor = mix(bgColor, finalColor, fogFactor);

    // Check if color matches transparent color
    float colorDist = length(baseColor - uTransparentColor);
    float alpha = 1.0;
    if (colorDist < uTolerance) {
        alpha = 0.0; // Make transparent
    }

    gl_FragColor = vec4(finalColor, alpha);
}
</script>

<script>
(function() {
  const canvas    = document.getElementById('glcanvas');
  const nSlider   = document.getElementById('nRange');
  const nLabel    = document.getElementById('nRangeValue');
  const isoSlider = document.getElementById('isoLevel');
  const isoLabel  = document.getElementById('isoLevelValue');
  const qSlider   = document.getElementById('qParam');
  const qLabel    = document.getElementById('qParamValue');
  const pSlider   = document.getElementById('pParam');
  const pLabel    = document.getElementById('pParamValue');
  const speedSlider = document.getElementById('speedParam');
  const speedLabel  = document.getElementById('speedParamValue');
  const fpsTargetSlider = document.getElementById('fpsTarget');
  const fpsTargetLabel  = document.getElementById('fpsTargetValue');
  const colorPicker = document.getElementById('colorPicker');
  const toleranceSlider = document.getElementById('toleranceParam');
  const toleranceLabel  = document.getElementById('toleranceValue');
  const functionSelect = document.getElementById('functionSelect');
  const animateBtn = document.getElementById('animateBtn');
  const colorSchemeSelect = document.getElementById('colorScheme');
  const solidColorPicker = document.getElementById('solidColor');
  const shadingModeSelect = document.getElementById('shadingMode');
  const brightnessSlider = document.getElementById('brightness');
  const brightnessLabel = document.getElementById('brightnessValue');
  const contrastSlider = document.getElementById('contrast');
  const contrastLabel = document.getElementById('contrastValue');
  const bgColorPicker = document.getElementById('bgColor');
  const fogAmountSlider = document.getElementById('fogAmount');
  const fogAmountLabel = document.getElementById('fogAmountValue');
  
  // Audio elements
  const audioFileInput = document.getElementById('audioFile');
  const audioPlayBtn = document.getElementById('audioPlayBtn');
  const audioSmoothingSlider = document.getElementById('audioSmoothing');
  const audioSmoothingLabel = document.getElementById('audioSmoothingValue');
  const audioToQSlider = document.getElementById('audioToQ');
  const audioToQLabel = document.getElementById('audioToQValue');
  const audioModeQSelect = document.getElementById('audioModeQ');
  const audioToPSlider = document.getElementById('audioToP');
  const audioToPLabel = document.getElementById('audioToPValue');
  const audioModePSelect = document.getElementById('audioModeP');
  const audioToNSlider = document.getElementById('audioToN');
  const audioToNLabel = document.getElementById('audioToNValue');
  const audioModeNSelect = document.getElementById('audioModeN');
  const audioToIsoSlider = document.getElementById('audioToIso');
  const audioToIsoLabel = document.getElementById('audioToIsoValue');
  const audioModeIsoSelect = document.getElementById('audioModeIso');
  const beatReactiveCheckbox = document.getElementById('beatReactive');
  const beatThresholdSlider = document.getElementById('beatThreshold');
  const beatThresholdLabel = document.getElementById('beatThresholdValue');
  const autoGainSlider = document.getElementById('autoGain');
  const autoGainLabel = document.getElementById('autoGainValue');
  const manualGainSlider = document.getElementById('manualGain');
  const manualGainLabel = document.getElementById('manualGainValue');
  
  // MIDI elements
  const midiEnableBtn = document.getElementById('midiEnableBtn');
  const midiStatus = document.getElementById('midiStatus');
  const midiLearnModeCheckbox = document.getElementById('midiLearnMode');
  const midiMappingsDisplay = document.getElementById('midiMappings');

  let gl, program;
  const attribs = {};
  const uniforms = {};

  // Flycam state
  let camPos   = [0, 0, 4.0];
  let camYaw   = 0.0;   // look toward -Z
  let camPitch = 0.0;
  const boxR   = 2.0;
  const fov    = Math.tan(45 * Math.PI / 180 * 0.5);

  const keys = {};          // single, global key map
  let pointerLocked = false;

  // Animation state
  let animating = false;
  let animTime = 0.0;
  let animStartTime = 0.0; // Absolute start time for time-based animation
  
  // Audio state
  let audioContext = null;
  let audioElement = null;
  let analyser = null;
  let dataArray = null;
  let bassLevel = 0.0;
  let midLevel = 0.0;
  let trebleLevel = 0.0;
  let lastBeatTime = 0;
  
  // Smoothed audio levels (exponential moving average)
  let smoothedBass = 0.0;
  let smoothedMid = 0.0;
  let smoothedTreble = 0.0;
  
  // Beat detection state
  let beatDetected = false;
  let beatFlash = 0.0;
  let bassHistory = [];
  const bassHistorySize = 43; // ~1 second at 43fps
  
  // RMS normalization
  let rmsLevel = 0.0;
  let rmsHistory = [];
  const rmsHistorySize = 10; // Faster adaptation
  
  // Oscillator phase for osc mode
  let oscPhase = 0.0;
  
  // MIDI state
  let midiAccess = null;
  let midiInputs = [];
  let midiMappings = {}; // { cc_number: { param: 'q', min: -2, max: 2 } }
  let midiLearnMode = false;
  let lastLearnedParam = null;

  // Render state for optimization
  let needsRender = true;
  let lastCamPos = [0, 0, 4.0];
  let lastCamYaw = 0.0;
  let lastCamPitch = 0.0;
  let lastParams = { n: 3.0, iso: 0.55, q: 0.0, p: 0.0, func: 0, tolerance: 0.1 };
  
  // Dynamic resolution scaling
  let resolutionScale = 1.0;
  let targetFPS = 30; // Will be updated from slider
  const minScale = 0.1;  // Can go down to 10%
  const maxScale = 1.0;
  let fpsHistory = [];
  const fpsHistorySize = 5;  // Smaller history for faster response
  let frameCount = 0;
  let fpsCheckTime = performance.now();

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    // Canvas internal size will be set in render based on resolutionScale
    needsRender = true;
  }

  function createShader(gl, type, src) {
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(sh));
      gl.deleteShader(sh);
      return null;
    }
    return sh;
  }

  function createProgram(gl, vsSrc, fsSrc) {
    const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
    if (!vs || !fs) return null;
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(prog));
      gl.deleteProgram(prog);
      return null;
    }
    return prog;
  }
  
  // ============ Audio Functions ============
  
  function initAudio(file) {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    if (audioElement) {
      audioElement.pause();
    }
    
    audioElement = new Audio();
    audioElement.src = URL.createObjectURL(file);
    audioElement.loop = true;
    
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    const bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    
    const source = audioContext.createMediaElementSource(audioElement);
    source.connect(analyser);
    analyser.connect(audioContext.destination);
    
    audioPlayBtn.disabled = false;
    audioPlayBtn.textContent = 'Play';
  }
  
  function toggleAudio() {
    if (!audioElement) return;
    
    if (audioElement.paused) {
      audioElement.play();
      audioPlayBtn.textContent = 'Pause';
    } else {
      audioElement.pause();
      audioPlayBtn.textContent = 'Play';
    }
  }
  
  function analyzeAudio() {
    if (!analyser || !dataArray) return;
    
    analyser.getByteFrequencyData(dataArray);
    
    // Split into precise frequency bands for better isolation
    // Bass: 20-250Hz (kick drum range)
    // Mid: 250Hz-4kHz (snare, vocals, instruments)
    // Treble: 4kHz+ (hi-hats, cymbals, brightness)
    const bassEnd = Math.floor(dataArray.length * 0.05);  // Lower bass range
    const midEnd = Math.floor(dataArray.length * 0.35);   // Wider mid range
    
    let bassSum = 0, midSum = 0, trebleSum = 0;
    let totalEnergy = 0;
    
    // Calculate weighted sums with emphasis on lower frequencies
    for (let i = 0; i < bassEnd; i++) {
      const weight = 1.0 + (bassEnd - i) / bassEnd; // Weight lower frequencies more
      bassSum += dataArray[i] * weight;
      totalEnergy += dataArray[i];
    }
    for (let i = bassEnd; i < midEnd; i++) {
      midSum += dataArray[i];
      totalEnergy += dataArray[i];
    }
    for (let i = midEnd; i < dataArray.length; i++) {
      trebleSum += dataArray[i];
      totalEnergy += dataArray[i];
    }
    
    // Normalize by bin count
    bassLevel = bassSum / (bassEnd * 255 * 2.0); // Account for weighting
    midLevel = midSum / ((midEnd - bassEnd) * 255);
    trebleLevel = trebleSum / ((dataArray.length - midEnd) * 255);
    
    // RMS normalization for auto-gain
    rmsLevel = Math.sqrt(totalEnergy / dataArray.length) / 255;
    rmsHistory.push(rmsLevel);
    if (rmsHistory.length > rmsHistorySize) rmsHistory.shift();
    const avgRMS = rmsHistory.reduce((a, b) => a + b, 0) / rmsHistory.length;
    const autoGain = parseFloat(autoGainSlider.value);
    const manualGain = parseFloat(manualGainSlider.value);
    // Target RMS of 0.4 instead of 0.3 for better response, with min threshold
    const gainFactor = avgRMS > 0.05 ? Math.min(5.0, (0.4 / avgRMS) * autoGain) : 1.0;
    const totalGain = gainFactor * manualGain;
    
    // Apply gain and clamp
    bassLevel = Math.min(1.0, bassLevel * totalGain);
    midLevel = Math.min(1.0, midLevel * totalGain);
    trebleLevel = Math.min(1.0, trebleLevel * totalGain);
    
    // Exponential smoothing for cleaner visuals
    const smoothing = parseFloat(audioSmoothingSlider.value);
    smoothedBass = smoothedBass * smoothing + bassLevel * (1.0 - smoothing);
    smoothedMid = smoothedMid * smoothing + midLevel * (1.0 - smoothing);
    smoothedTreble = smoothedTreble * smoothing + trebleLevel * (1.0 - smoothing);
    
    // Advanced beat detection with adaptive threshold
    beatFlash *= 0.85; // Decay flash
    bassHistory.push(smoothedBass);
    if (bassHistory.length > bassHistorySize) bassHistory.shift();
    
    if (bassHistory.length >= bassHistorySize) {
      const avgBass = bassHistory.reduce((a, b) => a + b, 0) / bassHistory.length;
      const variance = bassHistory.reduce((sum, val) => sum + Math.pow(val - avgBass, 2), 0) / bassHistory.length;
      const threshold = parseFloat(beatThresholdSlider.value);
      const adaptiveThreshold = avgBass + Math.sqrt(variance) * threshold;
      
      const now = performance.now();
      if (smoothedBass > adaptiveThreshold && smoothedBass > 0.3 && now - lastBeatTime > 150) {
        beatDetected = true;
        beatFlash = 1.0;
        lastBeatTime = now;
      } else {
        beatDetected = false;
      }
    }
  }
  
  function applyAudioToParams() {
    if (!audioElement || audioElement.paused) return;
    
    analyzeAudio();
    
    // Update oscillator phase
    oscPhase += 0.1;
    
    const audioToQ = parseFloat(audioToQSlider.value);
    const audioToP = parseFloat(audioToPSlider.value);
    const audioToN = parseFloat(audioToNSlider.value);
    const audioToIso = parseFloat(audioToIsoSlider.value);
    
    const modeQ = audioModeQSelect.value;
    const modeP = audioModePSelect.value;
    const modeN = audioModeNSelect.value;
    const modeIso = audioModeIsoSelect.value;
    
    // Apply different modulation modes
    function applyMode(level, amount, mode, center = 0.0) {
      if (mode === 'add') {
        // Additive: bipolar modulation around center
        return (level - 0.5) * amount * 2.0;
      } else if (mode === 'mult') {
        // Multiplicative: scales with audio
        return center * (level * amount);
      } else { // 'osc'
        // Oscillator: audio controls amplitude of sine wave
        return Math.sin(oscPhase + level * Math.PI * 2) * amount * level;
      }
    }
    
    let qMod = applyMode(smoothedBass, audioToQ, modeQ, 0.0);
    let pMod = applyMode(smoothedMid, audioToP, modeP, 0.0);
    let nMod = applyMode(smoothedTreble, audioToN, modeN, 1.0);
    let isoMod = applyMode(smoothedBass, audioToIso, modeIso, 0.0);
    
    // Add beat-reactive brightness flash
    let brightnessMod = 0.0;
    if (beatReactiveCheckbox.checked && beatFlash > 0.01) {
      brightnessMod = beatFlash * 0.5; // Flash on beat
    }
    
    return {
      qMod,
      pMod,
      nMod,
      isoMod,
      brightnessMod
    };
  }
  
  // ============ MIDI Functions ============
  
  async function enableMIDI() {
    try {
      midiAccess = await navigator.requestMIDIAccess();
      midiStatus.textContent = 'MIDI enabled';
      
      // Process existing inputs
      midiInputs = Array.from(midiAccess.inputs.values());
      if (midiInputs.length > 0) {
        midiStatus.textContent = `Connected: ${midiInputs.length} device(s)`;
        midiInputs.forEach(input => {
          input.onmidimessage = handleMIDIMessage;
        });
      } else {
        midiStatus.textContent = 'No MIDI devices found';
      }
      
      // Listen for hot-plug
      midiAccess.onstatechange = (e) => {
        if (e.port.type === 'input') {
          midiInputs = Array.from(midiAccess.inputs.values());
          if (midiInputs.length > 0) {
            midiStatus.textContent = `Connected: ${midiInputs.length} device(s)`;
            e.port.onmidimessage = handleMIDIMessage;
          } else {
            midiStatus.textContent = 'No MIDI devices found';
          }
        }
      };
    } catch (err) {
      console.error('MIDI access failed:', err);
      midiStatus.textContent = 'MIDI not available';
    }
  }
  
  function handleMIDIMessage(event) {
    const [status, cc, value] = event.data;
    
    // Only handle CC messages (0xB0-0xBF)
    if ((status & 0xF0) !== 0xB0) return;
    
    // Learn mode: map this CC to the last touched parameter
    if (midiLearnMode && lastLearnedParam) {
      const slider = getSliderByParam(lastLearnedParam);
      if (slider) {
        const min = parseFloat(slider.min);
        const max = parseFloat(slider.max);
        midiMappings[cc] = { param: lastLearnedParam, min, max };
        updateMIDIMappingsDisplay();
        midiLearnMode = false;
        midiLearnModeCheckbox.checked = false;
        lastLearnedParam = null;
      }
      return;
    }
    
    // Apply existing mapping
    const mapping = midiMappings[cc];
    if (mapping) {
      const normalized = value / 127.0;
      const mappedValue = mapping.min + normalized * (mapping.max - mapping.min);
      
      const slider = getSliderByParam(mapping.param);
      const label = getLabelByParam(mapping.param);
      if (slider && label) {
        slider.value = mappedValue;
        if (mapping.param === 'n' || mapping.param === 'iso' || mapping.param === 'tolerance' || mapping.param === 'fog') {
          label.textContent = mappedValue.toFixed(2);
        } else if (mapping.param === 'brightness' || mapping.param === 'contrast') {
          label.textContent = mappedValue.toFixed(1);
        } else {
          label.textContent = mappedValue.toFixed(2);
        }
        needsRender = true;
      }
    }
  }
  
  function getSliderByParam(param) {
    const map = {
      'q': qSlider,
      'p': pSlider,
      'n': nSlider,
      'iso': isoSlider,
      'brightness': brightnessSlider,
      'contrast': contrastSlider,
      'fog': fogAmountSlider,
      'tolerance': toleranceSlider
    };
    return map[param] || null;
  }
  
  function getLabelByParam(param) {
    const map = {
      'q': qLabel,
      'p': pLabel,
      'n': nLabel,
      'iso': isoLabel,
      'brightness': brightnessLabel,
      'contrast': contrastLabel,
      'fog': fogAmountLabel,
      'tolerance': toleranceLabel
    };
    return map[param] || null;
  }
  
  function updateMIDIMappingsDisplay() {
    const entries = Object.entries(midiMappings);
    if (entries.length === 0) {
      midiMappingsDisplay.textContent = 'No mappings';
      return;
    }
    
    midiMappingsDisplay.innerHTML = entries.map(([cc, mapping]) => 
      `CC${cc} â†’ ${mapping.param}`
    ).join('<br>');
  }
  
  function trackParamInteraction(paramName) {
    if (midiLearnMode) {
      lastLearnedParam = paramName;
      midiStatus.textContent = `Waiting for CC (${paramName})...`;
    }
  }

  function initGL() {
    gl = canvas.getContext('webgl');
    if (!gl) {
      alert('WebGL not supported');
      return;
    }
    const vsSource = document.getElementById('vs').textContent;
    const fsSource = document.getElementById('fs').textContent;
    program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    attribs.aPosition   = gl.getAttribLocation(program, 'aPosition');
    uniforms.uResolution = gl.getUniformLocation(program, 'uResolution');
    uniforms.uCamPos     = gl.getUniformLocation(program, 'uCamPos');
    uniforms.uCamForward = gl.getUniformLocation(program, 'uCamForward');
    uniforms.uCamRight   = gl.getUniformLocation(program, 'uCamRight');
    uniforms.uCamUp      = gl.getUniformLocation(program, 'uCamUp');
    uniforms.uFov        = gl.getUniformLocation(program, 'uFov');
    uniforms.uBoxR       = gl.getUniformLocation(program, 'uBoxR');
    uniforms.uNRange     = gl.getUniformLocation(program, 'uNRange');
    uniforms.uIsoLevel   = gl.getUniformLocation(program, 'uIsoLevel');
    uniforms.uQ          = gl.getUniformLocation(program, 'uQ');
    uniforms.uP          = gl.getUniformLocation(program, 'uP');
    uniforms.uTime       = gl.getUniformLocation(program, 'uTime');
    uniforms.uTransparentColor = gl.getUniformLocation(program, 'uTransparentColor');
    uniforms.uTolerance  = gl.getUniformLocation(program, 'uTolerance');
    uniforms.uFunction   = gl.getUniformLocation(program, 'uFunction');
    uniforms.uColorScheme = gl.getUniformLocation(program, 'uColorScheme');
    uniforms.uSolidColor = gl.getUniformLocation(program, 'uSolidColor');
    uniforms.uShadingMode = gl.getUniformLocation(program, 'uShadingMode');
    uniforms.uBrightness = gl.getUniformLocation(program, 'uBrightness');
    uniforms.uContrast = gl.getUniformLocation(program, 'uContrast');
    uniforms.uBgColor = gl.getUniformLocation(program, 'uBgColor');
    uniforms.uFogAmount = gl.getUniformLocation(program, 'uFogAmount');

    const quadVerts = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1
    ]);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(attribs.aPosition);
    gl.vertexAttribPointer(attribs.aPosition, 2, gl.FLOAT, false, 0, 0);

    gl.clearColor(0, 0, 0, 1);

    gl.uniform1f(uniforms.uBoxR, boxR);
    gl.uniform1f(uniforms.uFov, fov);
    
    // Enable blending for transparency
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  }

  function normalize3(v) {
    const l = Math.hypot(v[0], v[1], v[2]) || 1;
    return [v[0]/l, v[1]/l, v[2]/l];
  }

  function cross3(a,b) {
    return [
      a[1]*b[2] - a[2]*b[1],
      a[2]*b[0] - a[0]*b[2],
      a[0]*b[1] - a[1]*b[0]
    ];
  }

  function updateCamera(dt) {
    const cy = Math.cos(camYaw), sy = Math.sin(camYaw);
    const cp = Math.cos(camPitch), sp = Math.sin(camPitch);
    const forward = normalize3([cy*cp, sp, sy*cp]);
    const upWorld = [0,1,0];
    let right = normalize3(cross3(forward, upWorld));
    let up    = normalize3(cross3(right, forward));

    const speed = 2.0;
    const s = speed * realDeltaTime; // Use real time delta, not frame delta

    let moved = false;

    if (keys['KeyW']) {
      camPos[0] += forward[0]*s;
      camPos[1] += forward[1]*s;
      camPos[2] += forward[2]*s;
      moved = true;
    }
    if (keys['KeyS']) {
      camPos[0] -= forward[0]*s;
      camPos[1] -= forward[1]*s;
      camPos[2] -= forward[2]*s;
      moved = true;
    }
    if (keys['KeyA']) {
      camPos[0] -= right[0]*s;
      camPos[1] -= right[1]*s;
      camPos[2] -= right[2]*s;
      moved = true;
    }
    if (keys['KeyD']) {
      camPos[0] += right[0]*s;
      camPos[1] += right[1]*s;
      camPos[2] += right[2]*s;
      moved = true;
    }
    if (keys['KeyQ']) {
      camPos[0] -= up[0]*s;
      camPos[1] -= up[1]*s;
      camPos[2] -= up[2]*s;
      moved = true;
    }
    if (keys['KeyE']) {
      camPos[0] += up[0]*s;
      camPos[1] += up[1]*s;
      camPos[2] += up[2]*s;
      moved = true;
    }

    // Check if camera changed
    if (moved || 
        camYaw !== lastCamYaw || 
        camPitch !== lastCamPitch ||
        camPos[0] !== lastCamPos[0] ||
        camPos[1] !== lastCamPos[1] ||
        camPos[2] !== lastCamPos[2]) {
      needsRender = true;
      lastCamYaw = camYaw;
      lastCamPitch = camPitch;
      lastCamPos = [...camPos];
    }

    gl.uniform3fv(uniforms.uCamPos, camPos);
    gl.uniform3fv(uniforms.uCamForward, forward);
    gl.uniform3fv(uniforms.uCamRight, right);
    gl.uniform3fv(uniforms.uCamUp, up);
  }

  let lastTime = performance.now();
  let realDeltaTime = 0.0; // Actual time delta for movement

  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    return [r, g, b];
  }

  function render() {
    if (!gl) return;
    const now = performance.now();
    const dt = (now - lastTime) / 1000.0;
    realDeltaTime = dt; // Store real delta time
    lastTime = now;

    // Update target FPS from slider
    targetFPS = parseFloat(fpsTargetSlider.value);

    // FPS tracking and dynamic resolution adjustment
    frameCount++;
    const timeSinceCheck = now - fpsCheckTime;
    if (timeSinceCheck > 200) { // Check every 200ms for faster response
      const currentFPS = (frameCount / timeSinceCheck) * 1000;
      fpsHistory.push(currentFPS);
      if (fpsHistory.length > fpsHistorySize) {
        fpsHistory.shift();
      }
      
      // Calculate average FPS
      const avgFPS = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
      
      // Adjust resolution scale based on FPS - more aggressive
      if (avgFPS < targetFPS * 0.85 && resolutionScale > minScale) {
        resolutionScale = Math.max(minScale, resolutionScale - 0.15);
        console.log(`FPS: ${avgFPS.toFixed(1)} - Reducing resolution to ${(resolutionScale * 100).toFixed(0)}%`);
      } else if (avgFPS > targetFPS * 1.1 && resolutionScale < maxScale) {
        resolutionScale = Math.min(maxScale, resolutionScale + 0.05);
        console.log(`FPS: ${avgFPS.toFixed(1)} - Increasing resolution to ${(resolutionScale * 100).toFixed(0)}%`);
      }
      
      frameCount = 0;
      fpsCheckTime = now;
    }

    // Update animation time - use absolute time for consistent speed
    if (animating) {
      animTime = (now - animStartTime) / 1000.0; // Seconds since animation started
      needsRender = true;
    }

    // Apply audio modulation
    const audioMods = applyAudioToParams();
    
    // Force render if audio is active
    if (audioMods) {
      needsRender = true;
    }
    
    // Check if parameters changed
    const currentParams = {
      n: parseFloat(nSlider.value),
      iso: parseFloat(isoSlider.value),
      q: parseFloat(qSlider.value),
      p: parseFloat(pSlider.value),
      func: parseInt(functionSelect.value),
      tolerance: parseFloat(toleranceSlider.value)
    };
    
    if (JSON.stringify(currentParams) !== JSON.stringify(lastParams)) {
      needsRender = true;
      lastParams = {...currentParams};
    }

    updateCamera(dt);

    // Only render if needed
    if (needsRender) {
      // Actually change canvas resolution based on scale
      const w = window.innerWidth;
      const h = window.innerHeight;
      const renderWidth = Math.max(1, Math.floor(w * resolutionScale));
      const renderHeight = Math.max(1, Math.floor(h * resolutionScale));
      
      // Only resize canvas if resolution changed
      if (canvas.width !== renderWidth || canvas.height !== renderHeight) {
        canvas.width = renderWidth;
        canvas.height = renderHeight;
      }
      
      gl.viewport(0, 0, renderWidth, renderHeight);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);
      
      // Use actual render resolution
      gl.uniform2f(uniforms.uResolution, renderWidth, renderHeight);
      
      // Apply audio modulation to parameters
      let nValue = currentParams.n;
      let isoValue = currentParams.iso;
      let qValue = currentParams.q;
      let pValue = currentParams.p;
      
      if (audioMods) {
        qValue += audioMods.qMod;
        pValue += audioMods.pMod;
        nValue += audioMods.nMod;
        isoValue += audioMods.isoMod;
      }
      
      gl.uniform1f(uniforms.uNRange, nValue);
      gl.uniform1f(uniforms.uIsoLevel, isoValue);
      
      // Upload time for time-varying functions
      gl.uniform1f(uniforms.uTime, now / 1000.0); // Time in seconds
      
      // Apply animation to q parameter if active
      if (animating) {
        const speed = parseFloat(speedSlider.value);
        qValue = Math.sin(animTime * speed) * 1.5;
        qLabel.textContent = qValue.toFixed(2);
      }
      gl.uniform1f(uniforms.uQ, qValue);
      gl.uniform1f(uniforms.uP, pValue);
      
      // Set transparent color and tolerance
      const rgbColor = hexToRgb(colorPicker.value);
      gl.uniform3fv(uniforms.uTransparentColor, rgbColor);
      gl.uniform1f(uniforms.uTolerance, currentParams.tolerance);
      gl.uniform1i(uniforms.uFunction, currentParams.func);
      
      // Set new rendering options
      gl.uniform1i(uniforms.uColorScheme, parseInt(colorSchemeSelect.value));
      const solidRgb = hexToRgb(solidColorPicker.value);
      gl.uniform3fv(uniforms.uSolidColor, solidRgb);
      gl.uniform1i(uniforms.uShadingMode, parseInt(shadingModeSelect.value));
      
      // Apply brightness with beat-reactive modulation
      let brightnessValue = parseFloat(brightnessSlider.value);
      if (audioMods && audioMods.brightnessMod) {
        brightnessValue += audioMods.brightnessMod;
      }
      gl.uniform1f(uniforms.uBrightness, brightnessValue);
      gl.uniform1f(uniforms.uContrast, parseFloat(contrastSlider.value));
      
      // Background and fog
      const bgRgb = hexToRgb(bgColorPicker.value);
      gl.uniform3fv(uniforms.uBgColor, bgRgb);
      gl.uniform1f(uniforms.uFogAmount, parseFloat(fogAmountSlider.value));

      gl.drawArrays(gl.TRIANGLES, 0, 6);
      
      needsRender = animating || (audioElement && !audioElement.paused); // Keep rendering during animation or audio
    }

    requestAnimationFrame(render);
  }

  // --- UI hooks ---

  nSlider.addEventListener('input', () => {
    nLabel.textContent = parseFloat(nSlider.value).toFixed(2);
    trackParamInteraction('n');
    needsRender = true;
  });
  isoSlider.addEventListener('input', () => {
    isoLabel.textContent = parseFloat(isoSlider.value).toFixed(2);
    trackParamInteraction('iso');
    needsRender = true;
  });
  qSlider.addEventListener('input', () => {
    qLabel.textContent = parseFloat(qSlider.value).toFixed(2);
    trackParamInteraction('q');
    needsRender = true;
  });
  pSlider.addEventListener('input', () => {
    pLabel.textContent = parseFloat(pSlider.value).toFixed(2);
    trackParamInteraction('p');
    needsRender = true;
  });
  speedSlider.addEventListener('input', () => {
    speedLabel.textContent = parseFloat(speedSlider.value).toFixed(1);
  });
  fpsTargetSlider.addEventListener('input', () => {
    fpsTargetLabel.textContent = fpsTargetSlider.value;
  });
  toleranceSlider.addEventListener('input', () => {
    toleranceLabel.textContent = parseFloat(toleranceSlider.value).toFixed(2);
    trackParamInteraction('tolerance');
    needsRender = true;
  });
  
  functionSelect.addEventListener('change', () => {
    needsRender = true;
  });
  
  colorPicker.addEventListener('input', () => {
    needsRender = true;
  });

  colorSchemeSelect.addEventListener('change', () => {
    needsRender = true;
  });

  solidColorPicker.addEventListener('input', () => {
    needsRender = true;
  });

  shadingModeSelect.addEventListener('change', () => {
    needsRender = true;
  });

  brightnessSlider.addEventListener('input', () => {
    brightnessLabel.textContent = parseFloat(brightnessSlider.value).toFixed(1);
    trackParamInteraction('brightness');
    needsRender = true;
  });

  contrastSlider.addEventListener('input', () => {
    contrastLabel.textContent = parseFloat(contrastSlider.value).toFixed(1);
    trackParamInteraction('contrast');
    needsRender = true;
  });

  bgColorPicker.addEventListener('input', () => {
    needsRender = true;
  });

  fogAmountSlider.addEventListener('input', () => {
    fogAmountLabel.textContent = parseFloat(fogAmountSlider.value).toFixed(2);
    trackParamInteraction('fog');
    needsRender = true;
  });

  animateBtn.addEventListener('click', () => {
    animating = !animating;
    if (animating) {
      animStartTime = performance.now(); // Reset start time
      animTime = 0.0;
    }
    if (!animating) {
      // Reset q to slider value when stopping animation
      qLabel.textContent = parseFloat(qSlider.value).toFixed(2);
    }
    animateBtn.textContent = animating ? 'Stop Animation' : 'Toggle Sin Animation';
    animateBtn.style.background = animating ? '#446' : '#334';
  });

  // Keyboard
  window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
  });
  window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
  });

  // Pointer lock / mouse look
  canvas.addEventListener('click', () => {
    canvas.requestPointerLock();
  });

  document.addEventListener('pointerlockchange', () => {
    pointerLocked = (document.pointerLockElement === canvas);
  });

  document.addEventListener('mousemove', (e) => {
    if (!pointerLocked) return;
    const sensitivity = 0.0025;
    camYaw   += e.movementX * sensitivity;
    camPitch -= e.movementY * sensitivity;
    const limit = Math.PI * 0.49;
    if (camPitch >  limit) camPitch =  limit;
    if (camPitch < -limit) camPitch = -limit;
    needsRender = true;
  });

  // Audio event listeners
  audioFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      initAudio(file);
    }
  });
  
  audioPlayBtn.addEventListener('click', toggleAudio);
  
  audioSmoothingSlider.addEventListener('input', () => {
    audioSmoothingLabel.textContent = parseFloat(audioSmoothingSlider.value).toFixed(2);
  });
  
  audioToQSlider.addEventListener('input', () => {
    audioToQLabel.textContent = parseFloat(audioToQSlider.value).toFixed(1);
  });
  
  audioToPSlider.addEventListener('input', () => {
    audioToPLabel.textContent = parseFloat(audioToPSlider.value).toFixed(1);
  });
  
  audioToNSlider.addEventListener('input', () => {
    audioToNLabel.textContent = parseFloat(audioToNSlider.value).toFixed(1);
  });
  
  audioToIsoSlider.addEventListener('input', () => {
    audioToIsoLabel.textContent = parseFloat(audioToIsoSlider.value).toFixed(2);
  });
  
  beatThresholdSlider.addEventListener('input', () => {
    beatThresholdLabel.textContent = parseFloat(beatThresholdSlider.value).toFixed(2);
  });
  
  autoGainSlider.addEventListener('input', () => {
    autoGainLabel.textContent = parseFloat(autoGainSlider.value).toFixed(1);
  });
  
  manualGainSlider.addEventListener('input', () => {
    manualGainLabel.textContent = parseFloat(manualGainSlider.value).toFixed(1);
  });
  
  // MIDI event listeners
  midiEnableBtn.addEventListener('click', enableMIDI);
  midiLearnModeCheckbox.addEventListener('change', () => {
    midiLearnMode = midiLearnModeCheckbox.checked;
    if (midiLearnMode) {
      midiStatus.textContent = 'Learn mode: touch a slider...';
    } else {
      midiStatus.textContent = midiAccess ? `Connected: ${midiInputs.length} device(s)` : 'Not connected';
      lastLearnedParam = null;
    }
  });
  
  window.addEventListener('resize', resize);

  // init
  resize();
  initGL();
  nLabel.textContent = parseFloat(nSlider.value).toFixed(2);
  isoLabel.textContent = parseFloat(isoSlider.value).toFixed(2);
  qLabel.textContent = parseFloat(qSlider.value).toFixed(2);
  pLabel.textContent = parseFloat(pSlider.value).toFixed(2);
  speedLabel.textContent = parseFloat(speedSlider.value).toFixed(1);
  fpsTargetLabel.textContent = fpsTargetSlider.value;
  toleranceLabel.textContent = parseFloat(toleranceSlider.value).toFixed(2);
  requestAnimationFrame(render);
})();
</script>
</body>
</html>

